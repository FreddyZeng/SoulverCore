{"metadata":{"role":"article","roleHeading":"Article","title":"Data from string parsing","modules":[{"name":"SoulverCore"}]},"hierarchy":{"paths":[["doc:\/\/app.soulver.core\/documentation\/SoulverCore"]]},"kind":"article","sections":[],"abstract":[{"type":"text","text":"A declarative & type-safe approach to extracting various data types out of strings"}],"seeAlsoSections":[{"generated":true,"title":"String extensions for quick data parsing","identifiers":["doc:\/\/app.soulver.core\/documentation\/SoulverCore\/DateParsing"]}],"schemaVersion":{"minor":3,"patch":0,"major":0},"identifier":{"url":"doc:\/\/app.soulver.core\/documentation\/SoulverCore\/DataParsing","interfaceLanguage":"swift"},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/soulvercore\/dataparsing"]}],"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"text":"SoulverCore gives you human-friendly, type-safe & performant data parsing from Swift strings.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Specify types you want to parse from a string. If they are present, you get back ready-to-use data primitives (not strings!)."}]},{"inlineContent":[{"text":"This approach to data parsing allows you to ignore:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The specifics of how the data you need is formatted in text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Random words (or other data points), surrounding the data you need"}],"type":"paragraph"}]}],"type":"orderedList"},{"anchor":"Examples","type":"heading","level":2,"text":"Examples"},{"inlineContent":[{"type":"text","text":"Let’s look at a few examples:"}],"type":"paragraph"},{"syntax":"swift","code":["let (testCount, failureCount, timeTaken) = \"Executed 4 tests, with 1 failure in 0.009 seconds\".find(.number, .number, .time)!","","testCount \/\/ 4","failureCount \/\/ 1","timeTaken \/\/ 0.009 seconds","","let (date, temperature, humidity) = \"On August 23, 2022 the temperature in Chicago was 68.3 ºF (with a humidity of 74%)\".find(.date, .temperature, .percentage)!","","date \/\/ August 23, 2022","temperature \/\/ 68.3 ºF","humidity \/\/ 74%","","let (earnings, fileSize, url) = \"Total Earnings From PDF: $12.2k (3.25 MB, at https:\/\/lifeadvice.co.uk\/pdfs\/download?id=guide)\".find(.currency, .fileSize, .url)!","","earnings \/\/ 12,200 USD","fileSize \/\/ 3.25 MB","url \/\/ https:\/\/lifeadvice.co.uk\/pdfs\/download?id=guide"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Note","type":"text"}]},{"text":": the returned data points are ","type":"text"},{"inlineContent":[{"type":"text","text":"not"}],"type":"strong"},{"type":"text","text":" strings. They are native Swift data types (available as elements on a tuple), on which you can immediately perform operations:"}]},{"syntax":"swift","code":["let numbers = \"100 + 20\".find(.number, .number)!","let sum = numbers.0 + numbers.1 \/\/ 120"],"type":"codeListing"},{"inlineContent":[{"text":"Up to 6 data points can be requested in a single call. Variadic generics are planned for Swift 6, so we’ll support more in the future.","type":"text"}],"type":"paragraph"},{"type":"heading","level":2,"anchor":"The-beauty-of-high-order-data-extraction","text":"The beauty of high order data extraction"},{"type":"paragraph","inlineContent":[{"text":"Observe the beauty of the higher order concepts used here: numbers come in many formats (1,000, 30k, .456), yet a simple “.number” query “matches” them all. And .date “matches” dates in  commonly used date formats.","type":"text"}]},{"inlineContent":[{"type":"text","text":"For cases where the locale plays a role in the format of data, you may specify a locale in the find method (otherwise the current system Locale is used):"}],"type":"paragraph"},{"syntax":"swift","code":["let europeanNumber = \"€1.333,24\".find(.currency, locale: Locale(identifier: \"en_DE\"))","let americanDate = \"05\/30\/21\".find(.date, locale: Locale(identifier: \"en_US\")) \/\/ month\/day\/year"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"Where possible, standard Swift primitives are returned (URL, Date, Decimal, etc). In cases where no Swift primitive wholly captures the data present in the string, a SoulverCore value type is returned with properties containing the relevant data."}],"type":"paragraph"},{"type":"heading","text":"Supported data types","anchor":"Supported-data-types","level":2},{"header":"row","alignments":["left","left","left"],"rows":[[[{"type":"paragraph","inlineContent":[{"type":"text","text":"Symbol"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"Match Examples"}]}],[{"inlineContent":[{"text":"Return Type","type":"text"}],"type":"paragraph"}]],[[{"type":"paragraph","inlineContent":[{"text":".number","type":"text"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"123.45, 10k, -.3, 3,000, 50_000"}]}],[{"inlineContent":[{"text":"Decimal","type":"text"}],"type":"paragraph"}]],[[{"type":"paragraph","inlineContent":[{"text":".binaryNumber","type":"text"}]}],[{"inlineContent":[{"type":"text","text":"0b1011010"}],"type":"paragraph"}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"UInt"}]}]],[[{"inlineContent":[{"type":"text","text":".hexNumber"}],"type":"paragraph"}],[{"type":"paragraph","inlineContent":[{"text":"0x31FE28","type":"text"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"UInt"}]}]],[[{"inlineContent":[{"type":"text","text":".boolean"}],"type":"paragraph"}],[{"inlineContent":[{"text":"‘true’ or ‘false’","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"text":"Bool","type":"text"}],"type":"paragraph"}]],[[{"inlineContent":[{"type":"text","text":".percentage"}],"type":"paragraph"}],[{"inlineContent":[{"text":"10%, 230.99%","type":"text"}],"type":"paragraph"}],[{"type":"paragraph","inlineContent":[{"text":"Decimal","type":"text"}]}]],[[{"inlineContent":[{"text":".date","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"text":"March 12, 2004, 21\/04\/77, July the 4th, etc","type":"text"}],"type":"paragraph"}],[{"type":"paragraph","inlineContent":[{"text":"Date","type":"text"}]}]],[[{"type":"paragraph","inlineContent":[{"type":"text","text":".unixTimestamp"}]}],[{"inlineContent":[{"type":"text","text":"1661259854"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"TimeInterval"}],"type":"paragraph"}]],[[{"type":"paragraph","inlineContent":[{"text":".place","type":"text"}]}],[{"inlineContent":[{"type":"text","text":"Paris, Tokyo, Bali, Israel"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"SoulverCore.Place"}],"type":"paragraph"}]],[[{"inlineContent":[{"text":".airport","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"text":"SFO, LAX, SYD","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"text":"SoulverCore.Place","type":"text"}],"type":"paragraph"}]],[[{"type":"paragraph","inlineContent":[{"text":".timezone","type":"text"}]}],[{"type":"paragraph","inlineContent":[{"text":"AEST, GMT, EST","type":"text"}]}],[{"inlineContent":[{"type":"text","text":"SoulverCore.Place"}],"type":"paragraph"}]],[[{"inlineContent":[{"type":"text","text":".currencyCode"}],"type":"paragraph"}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"USD, EUR, DOGE"}]}],[{"type":"paragraph","inlineContent":[{"text":"String","type":"text"}]}]],[[{"type":"paragraph","inlineContent":[{"type":"text","text":".currency"}]}],[{"type":"paragraph","inlineContent":[{"text":"$10.00, AU$30k, 350 JPY","type":"text"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"SoulverCore.UnitExpression"}]}]],[[{"type":"paragraph","inlineContent":[{"text":".time","type":"text"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"10 s, 3 min, 4 weeks"}]}],[{"inlineContent":[{"text":"SoulverCore.UnitExpression","type":"text"}],"type":"paragraph"}]],[[{"type":"paragraph","inlineContent":[{"text":".distance","type":"text"}]}],[{"inlineContent":[{"type":"text","text":"10 km, 3 miles, 4 cm"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"SoulverCore.UnitExpression"}],"type":"paragraph"}]],[[{"inlineContent":[{"text":".temperature","type":"text"}],"type":"paragraph"}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"25 °C, 77 °F, 10C, 5 F"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"SoulverCore.UnitExpression"}]}]],[[{"type":"paragraph","inlineContent":[{"text":".weight","type":"text"}]}],[{"inlineContent":[{"type":"text","text":"10kg, 45 lb"}],"type":"paragraph"}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"SoulverCore.UnitExpression"}]}]],[[{"type":"paragraph","inlineContent":[{"type":"text","text":".area"}]}],[{"inlineContent":[{"type":"text","text":"30 m2, 40 in2"}],"type":"paragraph"}],[{"inlineContent":[{"text":"SoulverCore.UnitExpression","type":"text"}],"type":"paragraph"}]],[[{"type":"paragraph","inlineContent":[{"type":"text","text":".speed"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"30 mph"}]}],[{"inlineContent":[{"text":"SoulverCore.UnitExpression","type":"text"}],"type":"paragraph"}]],[[{"type":"paragraph","inlineContent":[{"type":"text","text":".volume"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"3 litres, 4 cups, 10 fl oz"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"SoulverCore.UnitExpression"}]}]],[[{"type":"paragraph","inlineContent":[{"text":".timespan","type":"text"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"3 hours 12 minutes"}]}],[{"inlineContent":[{"type":"text","text":"SoulverCore.Timespan"}],"type":"paragraph"}]],[[{"type":"paragraph","inlineContent":[{"type":"text","text":".laptime"}]}],[{"inlineContent":[{"text":"01:30:22.490 (hh:mm:ss.ms)","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"text":"SoulverCore.Laptime","type":"text"}],"type":"paragraph"}]],[[{"type":"paragraph","inlineContent":[{"type":"text","text":".timecode"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"03:10:21:16 (hh:mm:ss:frames)"}]}],[{"type":"paragraph","inlineContent":[{"text":"SoulverCore.Frametime","type":"text"}]}]],[[{"type":"paragraph","inlineContent":[{"text":".pitch","type":"text"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"A4, Bb7, C#9"}]}],[{"inlineContent":[{"type":"text","text":"SoulverCore.Pitch"}],"type":"paragraph"}]],[[{"type":"paragraph","inlineContent":[{"text":".url","type":"text"}]}],[{"inlineContent":[{"text":"https:\/\/soulver.app","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"URL"}],"type":"paragraph"}]],[[{"inlineContent":[{"type":"text","text":".emailAddress"}],"type":"paragraph"}],[{"type":"paragraph","inlineContent":[{"text":"bob@hotmail.com","type":"text"}]}],[{"type":"paragraph","inlineContent":[{"text":"String","type":"text"}]}]],[[{"inlineContent":[{"type":"text","text":".hashTag"}],"type":"paragraph"}],[{"type":"paragraph","inlineContent":[{"text":"#this_is_a_tag","type":"text"}]}],[{"type":"paragraph","inlineContent":[{"text":"String","type":"text"}]}]],[[{"type":"paragraph","inlineContent":[{"type":"text","text":".whitespace"}]}],[{"type":"paragraph","inlineContent":[{"text":"All whitespace characters (including tabs) are collapsed into a single whitespace token","type":"text"}]}],[{"inlineContent":[{"type":"text","text":"String"}],"type":"paragraph"}]]],"type":"table"},{"level":2,"anchor":"Finding-data-in-strings","text":"Finding data in strings","type":"heading"},{"inlineContent":[{"type":"text","text":"As we saw above, finding a data point in a string is as simple as asking for it:"}],"type":"paragraph"},{"code":["let percent = \"Results of likeness test: 83% match\".find(.percentage)","\/\/ percent is the decimal 0.83"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Extracting multiple data points is no harder. A tuple is returned with the correct number of arguments and data types:"}]},{"syntax":"swift","code":["let payrollEntry = \"CREDIT\t\t\t03\/02\/2022\t\t\tPayroll from employer\t\t\t\t$200.23\" \/\/ this string has inconsistent whitespace between entities, but this isn't a problem for us","let (date, currency) = payrollEntry.find(.date, .currency)!","date \/\/ Either February 3, or March 2, depending on your system locale","currency \/\/ UnitExpression object (use .value to get the decimalValue, and .unit.identifier to get the currency code - USD)"],"type":"codeListing"},{"text":"Extracting a data point from an array of strings","level":2,"type":"heading","anchor":"Extracting-a-data-point-from-an-array-of-strings"},{"inlineContent":[{"type":"text","text":"We can also call find with a single data type on an array of strings, and get back an array of the corresponding data type of the match:"}],"type":"paragraph"},{"syntax":"swift","code":["let amounts = [\"Zac spent $50\", \"Molly spent US$81.9 (with her 10% discount)\", \"Jude spent $43.90 USD\"].find(.currency)","","let totalAmount = amounts.reduce(0.0) {","    $0 + $1.value","}","","\/\/ totalAmount is $175.80"],"type":"codeListing"},{"level":2,"type":"heading","text":"Transforming data in strings","anchor":"Transforming-data-in-strings"},{"type":"paragraph","inlineContent":[{"text":"Imagine we wanted to standardize the whitespace in the string from the previous example:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["let standardized = \"CREDIT\t\t\t03\/02\/2022\t\t\tPayroll from employer\t\t\t\t$200.23\".replacingAll(.whitespace) { whitespace in","    return \" \"","}","","\/\/ standardized is \"CREDIT 03\/02\/2022 Payroll from employer $200.23\""]},{"inlineContent":[{"type":"text","text":"Or perhaps you want to convert European formatted numbers into Swift “standard” ones:"}],"type":"paragraph"},{"type":"codeListing","code":["let standardized = \"10.330,99 8.330,22 330,99\".replacingAll(.number, locale: Locale(identifier: \"en_DE\")) { number in","    return NumberFormatter.localizedString(from: number as NSNumber, number: .decimal)","}","","\/\/ standardized is \"10,330.99 8,330.22 330.99\")"],"syntax":"swift"},{"inlineContent":[{"type":"text","text":"Or perhaps you want to convert Celsius temperatures into Fahrenheit:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["let convertedTemperatures = [\"25 °C\", \"12.5 degrees celsius\", \"-22.6 C\"].replacingAll(.temperature) { celsius in","    ","    let measurementC: Measurement<UnitTemperature> = Measurement(value: celsius.value.doubleValue, unit: .celsius)","    let measurementF = measurementC.converted(to: .fahrenheit)","    ","    let formatter = MeasurementFormatter()","    formatter.unitOptions = .providedUnit","    return formatter.string(from: measurementF)","    ","}","","\/\/ convertedTemperatures is [\"77°F\", \"54.5°F\", \"-8.68°F\"]"]},{"level":2,"anchor":"Extending-SoulverCore-with-your-own-custom-types","text":"Extending SoulverCore with your own custom types","type":"heading"},{"inlineContent":[{"type":"text","text":"Let’s imagine we had strings with the following format, describing some containers:"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"“Color: blue, size: medium, volume: 12.5 cm3”"}]}]},{"content":[{"inlineContent":[{"text":"“Color: red, size: small, volume: 6.2 cm3”","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"“Color: yellow, size: large, volume: 17.82 cm3”","type":"text"}]}]}]},{"type":"paragraph","inlineContent":[{"text":"We want to extract this data into a custom Swift type that represents a Container.","type":"text"}]},{"type":"orderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"Define our model classes (if they don’t exist already)"}],"type":"paragraph"}]}]},{"code":["enum Color: String, RawRepresentable {","\tcase blue","\tcase red","\tcase yellow","}","","enum Size: String, RawRepresentable {","\tcase small","\tcase medium","\tcase large","}","","struct Container {","   let color: Color","   let size: Size","   let volume: Decimal","","   init(_ data: (Color, Size, UnitExpression)) {","        self.color = data.0","        self.size = data.1","        self.volume = data.2.value","    }","}"],"type":"codeListing","syntax":"swift"},{"type":"orderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Then create parsers for Color and Size, and add them static variables on DataPoint"}]}]}],"start":2},{"code":["struct ColorParser: DataFromTokenParser {","    typealias DataType = Color","    ","    func parseDataFrom(token: SoulverCore.Token) -> Color? {","        return Color(rawValue: token.stringValue.lowercased())","    }","}","","struct SizeParser: DataFromTokenParser {","    typealias DataType = Size","","    func parseDataFrom(token: SoulverCore.Token) -> Size? {","        return Size(rawValue: token.stringValue.lowercased())","    }","}","","extension DataPoint {","    static var color: DataPoint<ColorParser> {","        return DataPoint<ColorParser>(parser: ColorParser())","    }","","    static var size: DataPoint<SizeParser> {","        return DataPoint<SizeParser>(parser: SizeParser())","    }","}"],"type":"codeListing","syntax":"swift"},{"type":"orderedList","start":3,"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"That’s all the setup. You can now parse the data from the string, and populate your model objects:"}]}]}]},{"type":"codeListing","syntax":"swift","code":["  let container1 = Container(\"Color: blue, size: medium, volume: 12.5 cm3\".find(.color, .size, .volume)!)","  let container2 = Container(\"Color: red, size: small, volume: 6.2 cm3\".find(.color, .size, .volume)!)","  let container3 = Container(\"Color: yellow, size: large, volume: 17.82 cm3\".find(.color, .size, .volume)!)"]},{"text":"Using SoulverCore as a parser inside Swift Regex Builder","anchor":"Using-SoulverCore-as-a-parser-inside-Swift-Regex-Builder","type":"heading","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"SoulverCore is able to be used to parse data inside the Swift regex builder DSL. This is often easier than figuring out how to match the format of your data with a regular expression."}]},{"type":"codeListing","syntax":"swift","code":["if #available(macOS 13.0, iOS 16.0, *) {","    let input = \"Cost: 365.45, Date: March 12, 2022\"","    ","    let regex = Regex {","        \"Cost: \"","        Capture {","            DataPoint<NumberFromTokenParser>.number","        }","        \", Date: \"","        Capture {","            DataPoint<DateFromTokenParser>.date","        }","    }","    ","    let match = input.wholeMatch(of: regex).1 \/\/ 365.45","}"]},{"level":2,"type":"heading","text":"Comparison with other data parsing approaches","anchor":"Comparison-with-other-data-parsing-approaches"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Apple’s toolkit for string parsing includes Regex, NSScanner & NSDataDetector. Let’s compare and contrast each of these with SoulverCore."}]},{"type":"heading","level":4,"anchor":"Regular-Expressions","text":"Regular Expressions"},{"type":"paragraph","inlineContent":[{"identifier":"https:\/\/en.wikipedia.org\/wiki\/Regular_expression","type":"reference","isActive":true},{"type":"text","text":" will always be with us, but ask yourself, do you "},{"type":"emphasis","inlineContent":[{"type":"text","text":"really"}]},{"type":"text","text":" want to use them for data processing?"}]},{"inlineContent":[{"type":"text","text":"They’re non-trivial to understand at a glance, and constructing a correct regex to match data is, at the minimum, tedious (if not mentally quite "},{"type":"emphasis","inlineContent":[{"type":"text","text":"challenging"}]},{"text":" sometimes).","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Regex only “sees” sets of characters\/numbers\/whitespace so it forces you to think about the string format of the data you want to parse, and also often about how to skip past other strings leading up to it."}]},{"inlineContent":[{"text":"So even with the ","type":"text"},{"inlineContent":[{"type":"text","text":"significant"}],"type":"strong"},{"type":"text","text":" enhancements to regex in Swift 5.7 (type-safe tuple matches & the regex builder syntax), regex makes you think about data parsing at the "},{"type":"emphasis","inlineContent":[{"text":"wrong level of abstraction","type":"text"}]},{"text":" (i.e. characters, rather than data types).","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"If Swift is to achieve its goal of becoming "},{"identifier":"https:\/\/github.com\/apple\/swift\/blob\/main\/docs\/StringManifesto.md","type":"reference","isActive":true},{"type":"text","text":", it needs something more human friendly at the level of abstraction of data, not character sets."}],"type":"paragraph"},{"level":4,"text":"NSScanner","type":"heading","anchor":"NSScanner"},{"inlineContent":[{"text":"A scanner is an imperative (rather than declarative) approach to parsing data out of strings. You move a scanner through a string step-by-step, scanning out the components that you want.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"One benefit of NSScanner is that it’s able to ignore parts of strings you don’t care about. However scanner still only knows about numbers and strings - not higher level data types.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here is a "},{"identifier":"https:\/\/stackoverflow.com\/questions\/594797\/how-to-use-nsscanner","isActive":true,"type":"reference"},{"type":"text","text":" that illustrates the use of NSScanner to scan the integer from the string “user logged (3 attempts)”."}]},{"type":"codeListing","syntax":"objc","code":["NSString *logString = @\"user logged (3 attempts)\";","NSString *numberString;","NSScanner *scanner = [NSScanner scannerWithString:logString];","[scanner scanUpToCharactersFromSet:[NSCharacterSet decimalDigitCharacterSet] intoString:nil];","[scanner scanCharactersFromSet:[NSCharacterSet decimalDigitCharacterSet] intoString:&numberString];","NSLog(@\"Attempts: %i\", [numberString intValue]); \/\/ 3"]},{"inlineContent":[{"type":"text","text":"Regex (in Swift 5.7+) is somewhat more concise"}],"type":"paragraph"},{"syntax":"swift","code":["","if #available(macOS 13.0, iOS 16.0, *) {","    let match = \"user logged (3 attempts)\".firstMatch(of: \/([+\\\\-]?[0-9]+)\/)","    let numberSubstring = match!.0","    let number = Int(numberSubstring)","}",""],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"And now SoulverCore:"}]},{"code":["let number = \"user logged (3 attempts)\".find(.number)"],"type":"codeListing","syntax":"swift"},{"text":"NSDataDetector","type":"heading","anchor":"NSDataDetector","level":4},{"type":"paragraph","inlineContent":[{"type":"text","text":"NSDataDetector is an NSRegularExpression subclass that is able to scan a string for dates, URLs, phone numbers, addresses, and flight details. It’s a great class, and supports many different formats. Additionally, it return propers data types from strings, like URL and Date (much like SoulverCore)."}]},{"type":"paragraph","inlineContent":[{"text":"Compare:","type":"text"}]},{"level":5,"text":"NSDataDetector","anchor":"NSDataDetector","type":"heading"},{"type":"codeListing","syntax":"swift","code":["let input = \"Learn more at https:\/\/fascinatingcaptain.com today.\"","let detector = try! NSDataDetector(types: NSTextCheckingResult.CheckingType.link.rawValue)","let url = detector.firstMatch(in: input, options: [], range: NSRange(location: 0, length: input.utf16.count))!.url!"]},{"level":5,"text":"SoulverCore","anchor":"SoulverCore","type":"heading"},{"syntax":"swift","type":"codeListing","code":["let url = \"Learn more at https:\/\/fascinatingcaptain.com today\".find(.url)"]},{"inlineContent":[{"text":"NSDataDetector’s downsides are that the API is not particularly “Swifty”, supported data types are limited, and it’s not part of the platform-independent implementation of Foundation (so you can’t use it on Linux, Windows, etc)","type":"text"}],"type":"paragraph"}]}],"references":{"https://github.com/apple/swift/blob/main/docs/StringManifesto.md":{"url":"https:\/\/github.com\/apple\/swift\/blob\/main\/docs\/StringManifesto.md","titleInlineContent":[{"text":"the world’s greatest string & data processing language","type":"text"}],"identifier":"https:\/\/github.com\/apple\/swift\/blob\/main\/docs\/StringManifesto.md","title":"the world’s greatest string & data processing language","type":"link"},"https://stackoverflow.com/questions/594797/how-to-use-nsscanner":{"identifier":"https:\/\/stackoverflow.com\/questions\/594797\/how-to-use-nsscanner","titleInlineContent":[{"type":"text","text":"StackOverflow post"}],"url":"https:\/\/stackoverflow.com\/questions\/594797\/how-to-use-nsscanner","type":"link","title":"StackOverflow post"},"doc://app.soulver.core/documentation/SoulverCore":{"abstract":[{"type":"text","text":"A powerful natural language calculation engine"}],"title":"SoulverCore","url":"\/documentation\/soulvercore","kind":"symbol","type":"topic","role":"collection","identifier":"doc:\/\/app.soulver.core\/documentation\/SoulverCore"},"https://en.wikipedia.org/wiki/Regular_expression":{"url":"https:\/\/en.wikipedia.org\/wiki\/Regular_expression","titleInlineContent":[{"text":"Regular expressions","type":"text"}],"identifier":"https:\/\/en.wikipedia.org\/wiki\/Regular_expression","title":"Regular expressions","type":"link"},"doc://app.soulver.core/documentation/SoulverCore/DateParsing":{"type":"topic","role":"article","abstract":[{"type":"text","text":"Add a natural language date scheduling feature to your Mac or iOS calendar or reminders app"}],"title":"Natural language date parsing","url":"\/documentation\/soulvercore\/dateparsing","identifier":"doc:\/\/app.soulver.core\/documentation\/SoulverCore\/DateParsing","kind":"article"}}}