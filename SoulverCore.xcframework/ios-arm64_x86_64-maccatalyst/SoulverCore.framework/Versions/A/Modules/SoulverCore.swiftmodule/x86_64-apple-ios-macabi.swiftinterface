// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.1.2 (swiftlang-6.1.2.1.2 clang-1700.0.13.5)
// swift-module-flags: -target x86_64-apple-ios13.6-macabi -enable-objc-interop -enable-library-evolution -swift-version 6 -enforce-exclusivity=checked -O -enable-experimental-feature DebugDescriptionMacro -module-name SoulverCore
// swift-module-flags-ignorable: -no-verify-emitted-module-interface -interface-compiler-version 6.1.2
import Darwin
import Foundation
import JavaScriptCore
import RegexBuilder
@_exported import SoulverCore
import Swift
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
import os
public class ECBCurrencyRateProvider : SoulverCore.CurrencyRateProvider, @unchecked Swift.Sendable {
  public init()
  public func updateRates() async -> Swift.Bool
  public func rateFor(request: SoulverCore.CurrencyRateRequest) -> Foundation.Decimal?
  @objc deinit
}
public struct Fraction : Swift.Equatable {
  public let decimalValue: Foundation.Decimal
  public let unitValue: SoulverCore.SCUnit?
  public static func == (a: SoulverCore.Fraction, b: SoulverCore.Fraction) -> Swift.Bool
}
public struct CalculationResult : Swift.Equatable, Swift.Hashable, Swift.Sendable {
  public init(evaluationResult: SoulverCore.EvaluationResult, stringValue: Swift.String, parsedExpression: SoulverCore.TokenList? = nil)
  public let stringValue: Swift.String
  public let evaluationResult: SoulverCore.EvaluationResult
  public let parsedExpression: SoulverCore.TokenList?
  public static func == (a: SoulverCore.CalculationResult, b: SoulverCore.CalculationResult) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension SoulverCore.CalculationResult {
  public var isEmptyResult: Swift.Bool {
    get
  }
  public var isPendingResult: Swift.Bool {
    get
  }
  public var isFailedResult: Swift.Bool {
    get
  }
}
public var EmptyResult: SoulverCore.CalculationResult {
  get
}
@_hasMissingDesignatedInitializers final public class VariableList : Swift.CustomDebugStringConvertible, Swift.Sendable {
  convenience public init(variables: [SoulverCore.Variable])
  final public func provideDefinitionsForValuesWith(definitionBlock: (SoulverCore.RawExpression) -> SoulverCore.CalculationResult)
  final public func allVariables() -> [SoulverCore.Variable]
  final public func variablesExludingLineReferences() -> [SoulverCore.Variable]
  final public func singleWordVariables() -> [SoulverCore.Variable]
  final public func multiWordVariables(reverseSortByLength: Swift.Bool) -> [SoulverCore.Variable]
  final public func setVariable(_ variable: SoulverCore.Variable)
  final public func setVariables(_ variables: [SoulverCore.Variable])
  final public func clearVariable(withName name: Swift.String)
  final public subscript(variableName: SoulverCore.VariableName) -> SoulverCore.Variable? {
    get
    set
  }
  final public var count: Swift.Int {
    get
  }
  final public var isEmpty: Swift.Bool {
    get
  }
  final public var isNotEmpty: Swift.Bool {
    get
  }
  final public var debugDescription: Swift.String {
    get
  }
  @objc deinit
}
extension SoulverCore.VariableList : Swift.Equatable, Swift.Hashable {
  public static func == (lhs: SoulverCore.VariableList, rhs: SoulverCore.VariableList) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
public struct TokenTypeSet : Swift.Sendable {
  public init(types: Swift.Set<SoulverCore.TokenType>)
  public let types: Swift.Set<SoulverCore.TokenType>
  public var count: Swift.Int {
    get
  }
  public func contains(_ tokenType: SoulverCore.TokenType) -> Swift.Bool
  public func containsTypesFrom(otherSet: SoulverCore.TokenTypeSet) -> Swift.Bool
}
public struct Substance : Swift.Equatable, Swift.Sendable {
  public let name: Swift.String
  public let value: Foundation.Decimal
  public var rateValue: SoulverCore.UnitRate {
    get
  }
  public static func == (a: SoulverCore.Substance, b: SoulverCore.Substance) -> Swift.Bool
}
public typealias TokenIndex = Swift.Int
public struct TokenIndexPath : Swift.Equatable {
  public init(tokenIndex: SoulverCore.TokenIndex, lineIndex: SoulverCore.LineIndex)
  public let tokenIndex: SoulverCore.TokenIndex
  public let lineIndex: SoulverCore.LineIndex
  public static func == (a: SoulverCore.TokenIndexPath, b: SoulverCore.TokenIndexPath) -> Swift.Bool
}
public typealias PitchNotation = Swift.String
public struct Pitch : Swift.Equatable {
  public static func == (a: SoulverCore.Pitch, b: SoulverCore.Pitch) -> Swift.Bool
}
public struct Token {
  public let type: SoulverCore.TokenType
  public let subType: SoulverCore.TokenSubType
  public var stringValue: Swift.String
  public var range: SoulverCore.Token.Range
  public var subtokens: SoulverCore.TokenList?
  public struct Range : Swift.Sendable, Swift.Hashable, Swift.Equatable {
    public let location: Swift.Int
    public let length: Swift.Int
    public var lowerBound: Swift.Int {
      get
    }
    public var upperBound: Swift.Int {
      get
    }
    public static let zero: SoulverCore.Token.Range
    public func contains(_ loc: Swift.Int) -> Swift.Bool
    public func contains(_ range: SoulverCore.Token.Range) -> Swift.Bool
    public var nsRange: Foundation.NSRange {
      get
    }
    public static func == (lhs: SoulverCore.Token.Range, rhs: Foundation.NSRange) -> Swift.Bool
    public static func == (lhs: Foundation.NSRange, rhs: SoulverCore.Token.Range) -> Swift.Bool
    public static func == (a: SoulverCore.Token.Range, b: SoulverCore.Token.Range) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension SoulverCore.Token : Swift.Equatable, Swift.Hashable, Swift.Comparable {
  public static func == (lhs: SoulverCore.Token, rhs: SoulverCore.Token) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public static func < (lhs: SoulverCore.Token, rhs: SoulverCore.Token) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension SoulverCore.Token : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension SoulverCore.Token {
  public var number: Foundation.Decimal? {
    get
  }
  public var scalarSymbol: SoulverCore.ScalarSymbol? {
    get
  }
  public var decimalValue: Foundation.Decimal {
    get
  }
  public var resolutionValue: SoulverCore.Resolution? {
    get
  }
  public var salesTaxValue: SoulverCore.SalesTax? {
    get
  }
  public var percentageValue: SoulverCore.Percentage {
    get
  }
  public var unitExpressionValue: SoulverCore.UnitExpression? {
    get
  }
  public var unitValue: SoulverCore.SCUnit? {
    get
  }
  public var calendarComponentValue: Foundation.Calendar.Component? {
    get
  }
  public var unitRateValue: SoulverCore.UnitRate? {
    get
  }
  public var percentageRateValue: SoulverCore.PercentageRate? {
    get
  }
  public var decimalRateValue: SoulverCore.DecimalRate? {
    get
  }
  public var datestampValue: SoulverCore.Datestamp? {
    get
  }
  public var dmsValue: SoulverCore.DegreesMinutesSeconds? {
    get
  }
  public var datespanValue: SoulverCore.Datespan? {
    get
  }
  public var dateComponentsValue: Foundation.DateComponents? {
    get
  }
  public var placeValue: SoulverCore.Place? {
    get
  }
  public var gpsCoordinatesValue: SoulverCore.GPSCoordinates? {
    get
  }
  public var pitchValue: SoulverCore.Pitch? {
    get
  }
  public var timeZoneValue: Foundation.TimeZone? {
    get
  }
  public var fractionValue: SoulverCore.Fraction? {
    get
  }
  public var timespanValue: SoulverCore.Timespan? {
    get
  }
  public var dateIntervalValue: Foundation.DateInterval? {
    get
  }
  public var booleanValue: Swift.Bool {
    get
  }
  public var laptimeValue: SoulverCore.Laptime? {
    get
  }
  public var frametimeValue: SoulverCore.Frametime? {
    get
  }
  public var keywordValue: (any SoulverCore.Keyword)? {
    get
  }
  public var errorValue: SoulverCore.EvaluationError? {
    get
  }
  public var variable: SoulverCore.Variable? {
    get
  }
  public var statisticType: SoulverCore.StatisticType? {
    get
  }
  public var isLineReference: Swift.Bool {
    get
  }
  public var isVariable: Swift.Bool {
    get
  }
  public var functionIdentifier: SoulverCore.FunctionIdentifier? {
    get
  }
  public var converterIdentifier: SoulverCore.ConverterIdentifier? {
    get
  }
  public var functionName: Swift.String? {
    get
  }
  public var urlValue: Foundation.URL? {
    get
  }
  public var dynamicVariableValue: (any SoulverCore.DynamicVariable)? {
    get
  }
}
public typealias CurrencyCode = Swift.String
@_hasMissingDesignatedInitializers public class TokenListSemantics {
  public enum EnumerationGranularity {
    case allTokens
    case meaningfulTokens
    case meaningfulAndContainerTokens
    case containerTokens
    public static func == (a: SoulverCore.TokenListSemantics.EnumerationGranularity, b: SoulverCore.TokenListSemantics.EnumerationGranularity) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public func enumerate(_ granularity: SoulverCore.TokenListSemantics.EnumerationGranularity = .meaningfulTokens, using: (SoulverCore.SemanticToken) -> Swift.Void)
  @objc deinit
}
public struct Timespan : Swift.Equatable {
  public let dateComponents: Foundation.DateComponents
  public static func == (a: SoulverCore.Timespan, b: SoulverCore.Timespan) -> Swift.Bool
}
extension SoulverCore.EngineCustomization {
  public static var standard: SoulverCore.EngineCustomization {
    get
  }
  public static var soulver: SoulverCore.EngineCustomization {
    get
  }
  public func isOperator(text: Swift.String) -> Swift.Bool
  public func isClassicFunction(text: Swift.String) -> Swift.Bool
  public func longFormNameFor(unitIdentifier: SoulverCore.UnitIdentifier) -> Swift.String?
  public func symbolFor(unitIdentifier: SoulverCore.UnitIdentifier) -> Swift.String?
  public var cities: [SoulverCore.City] {
    get
  }
  public var countries: [SoulverCore.Country] {
    get
  }
  public var airports: [SoulverCore.Airport] {
    get
  }
  public static var realWorldCurrencies: Swift.Set<SoulverCore.UnitIdentifier> {
    get
  }
  public static var cryptoCurrencies: Swift.Set<SoulverCore.UnitIdentifier> {
    get
  }
  @available(*, deprecated, message: "Use `EngineCustomization/currencySymbolSettings` instead.")
  public var customSymbols: [SoulverCore.UnitSymbolReplacement] {
    get
    set
  }
}
public struct Frametime : Swift.Equatable {
  public static func == (a: SoulverCore.Frametime, b: SoulverCore.Frametime) -> Swift.Bool
}
public struct WeatherDataRequest {
  public let function: SoulverCore.FunctionIdentifier
  public let location: SoulverCore.Place
  public let datestamp: SoulverCore.Datestamp?
  public var date: Foundation.Date? {
    get
  }
}
public protocol WeatherDataProvider : AnyObject {
  func dataFor(request: SoulverCore.WeatherDataRequest) async throws -> SoulverCore.EvaluationResult?
}
public protocol CurrencyRateProvider : AnyObject {
  func rateFor(request: SoulverCore.CurrencyRateRequest) -> Foundation.Decimal?
  func fetchRateInBackgroundFor(request: SoulverCore.CurrencyRateRequest) async -> Foundation.Decimal?
}
extension SoulverCore.CurrencyRateProvider {
  public func fetchRateInBackgroundFor(request: SoulverCore.CurrencyRateRequest) async -> Foundation.Decimal?
}
public struct CurrencyRateRequest : Swift.Sendable {
  public let fromCurrency: SoulverCore.CurrencyCode
  public let toCurrency: SoulverCore.CurrencyCode
  public let quantity: Foundation.Decimal
  public let date: Foundation.Date?
  public let fromCurrencyUnit: SoulverCore.UnitIdentifier
  public let toCurrencyUnit: SoulverCore.UnitIdentifier
}
extension SoulverCore.CurrencyRateRequest {
  public var unitIdentifier: SoulverCore.UnitIdentifier {
    get
  }
  public var baseCurrencyQuantity: Swift.Double {
    get
  }
  public var currencyCode: SoulverCore.CurrencyCode {
    get
  }
  public var baseCurrencyCode: SoulverCore.CurrencyCode {
    get
  }
}
public protocol PlaceDataProvider : AnyObject {
  func placeDataFor(request: Swift.String) async throws -> SoulverCore.PlaceData?
  func distanceBetween(location1: SoulverCore.PlaceData.Coordinates, location2: SoulverCore.PlaceData.Coordinates) -> SoulverCore.UnitExpression?
}
extension SoulverCore.PlaceDataProvider {
  public func distanceBetween(location1: SoulverCore.PlaceData.Coordinates, location2: SoulverCore.PlaceData.Coordinates) -> SoulverCore.UnitExpression?
}
public struct PlaceData : Swift.Codable, Swift.Hashable, Swift.Equatable, Swift.Sendable {
  public init(name: Swift.String, timeZone: Foundation.TimeZone, coordinates: SoulverCore.PlaceData.Coordinates? = nil)
  public let name: Swift.String
  public let timeZone: Foundation.TimeZone
  public let coordinates: SoulverCore.PlaceData.Coordinates?
  public struct Coordinates : Swift.Codable, Swift.Hashable, Swift.Equatable, Swift.Sendable {
    public init(latitude: Swift.Double, longitude: Swift.Double)
    public let latitude: Swift.Double
    public let longitude: Swift.Double
    public static func == (a: SoulverCore.PlaceData.Coordinates, b: SoulverCore.PlaceData.Coordinates) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public static func == (a: SoulverCore.PlaceData, b: SoulverCore.PlaceData) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public enum EvaluationError : Swift.Error {
  case UnitMismatch
  case UnsupportedUnitMultiplication
  case UnsupportedRate
  case UnsupportedExponentOperation
  case Infinity
  case ImaginaryNumber
  case DivideByZero
  case BadDivision
  case ImpreciseResult
  case SilentError
  case Other
  public static func == (a: SoulverCore.EvaluationError, b: SoulverCore.EvaluationError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum UnitType : Swift.String, Swift.CaseIterable, Swift.Codable, Swift.Sendable {
  case acceleration
  case amountOfSubstance
  case angle
  case angularVelocity
  case area
  case concentrationMass
  case currency
  case dataStorage
  case dataTransfer
  case dispersion
  case duration
  case electricCharge
  case electricCurrent
  case electricPotential
  case electricResistance
  case electricConductance
  case electricalInductance
  case electricalCapacitance
  case magneticFlux
  case magneticFluxDensity
  case energy
  case force
  case frameRate
  case frames
  case frequency
  case fuelConsumption
  case fuelEconomy
  case illuminance
  case length
  case mass
  case other
  case period
  case power
  case pressure
  case screenDensity
  case speed
  case substanceConcentraion
  case temperature
  case torque
  case volume
  public var label: Swift.String {
    get
  }
  public var baseUnitIdentifier: SoulverCore.UnitIdentifier {
    get
  }
  public var associatedOtherUnits: [SoulverCore.UnitIdentifier] {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias AllCases = [SoulverCore.UnitType]
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [SoulverCore.UnitType] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public enum UnitIdentifier : Swift.String, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Sendable {
  case degrees
  case arcMinutes
  case arcSeconds
  case radians
  case gradians
  case revolutions
  case squareMegameters
  case squareKilometers
  case squareMeters
  case squareCentimeters
  case squareDecimeters
  case squareMillimeters
  case squareMicrometers
  case squareNanometers
  case squareInches
  case squareFeet
  case squareYards
  case squareMiles
  case acres
  case ares
  case hectares
  case litersPerKilometer
  case litersPer100Kilometers
  case milesPerImperialGallon
  case milesPerGallon
  case gramsPerLiter
  case kilometersPerLiter
  case seconds
  case minutes
  case hours
  case days
  case weekdays
  case nights
  case weeks
  case months
  case years
  case picoseconds
  case nanoseconds
  case microseconds
  case milliseconds
  case joules
  case kilojoules
  case megajoules
  case gigajoules
  case kilocalories
  case calories
  case wattSeconds
  case wattMinutes
  case wattHours
  case kilowattHours
  case megawattHours
  case gigawattHours
  case terawattHours
  case terahertz
  case gigahertz
  case megahertz
  case kilohertz
  case hertz
  case millihertz
  case microhertz
  case nanohertz
  case framesPerSecond
  case radiansPerSecond
  case revolutionsPerSecond
  case revolutionsPerMinute
  case megameters
  case hectokilometers
  case kilometers
  case hectometers
  case decameters
  case meters
  case decimeters
  case centimeters
  case millimeters
  case micrometers
  case nanometers
  case picometers
  case inches
  case feet
  case yards
  case miles
  case scandinavianMiles
  case lightyears
  case astronomicalUnits
  case nauticalMiles
  case fathoms
  case furlongs
  case parsecs
  case cycles
  case lux
  case kilograms
  case grams
  case decigrams
  case centigrams
  case milligrams
  case micrograms
  case nanograms
  case picograms
  case ounces
  case pounds
  case stones
  case metricTons
  case shortTons
  case carats
  case ouncesTroy
  case slugs
  case terawatts
  case gigawatts
  case megawatts
  case kilowatts
  case watts
  case milliwatts
  case microwatts
  case nanowatts
  case picowatts
  case femtowatts
  case horsepower
  case pascals
  case gigapascals
  case megapascals
  case kilopascals
  case hectopascals
  case inchesOfMercury
  case atmospheres
  case bars
  case millibars
  case millimetersOfMercury
  case poundsForcePerSquareInch
  case kilopoundsForcePerSquareInch
  case megapoundsForcePerSquareInch
  case metersPerSecond
  case feetPerSecond
  case kilometersPerHour
  case milesPerHour
  case knots
  case kelvin
  case celsius
  case fahrenheit
  case liters
  case kiloliters
  case megaliters
  case milliliters
  case microliters
  case nanoliters
  case centiliters
  case deciliters
  case cubicKilometers
  case cubicMeters
  case cubicDecimeters
  case cubicCentimeters
  case cubicMillimeters
  case cubicNanometers
  case cubicMicrometers
  case cubicInches
  case cubicFeet
  case cubicYards
  case cubicMiles
  case acreFeet
  case bushels
  case barrels
  case teaspoons
  case tablespoons
  case fluidOunces
  case cups
  case pints
  case quarts
  case gallons
  case imperialTeaspoons
  case imperialTablespoons
  case imperialFluidOunces
  case imperialPints
  case imperialQuarts
  case imperialGallons
  case metricCups
  case metricTeaspoons
  case metricTablespoons
  case metricAUTablespoons
  case ppi
  case pixel
  case em
  case rem
  case point
  case frames
  case milligramsPerDeciliter
  case partsPerMillion
  case moles
  case millimoles
  case micromoles
  case nanomoles
  case molar
  case newtons
  case kilonewtons
  case meganewtons
  case giganewtons
  case millinewtons
  case micronewtons
  case nanonewtons
  case poundals
  case poundsOfForce
  case ouncesOfForce
  case newtonMeters
  case poundFeet
  case poundInches
  case ounceInches
  case metersPerSecondSquared
  case feetPerSecondSquared
  case gravity
  case coulombs
  case megaampereHours
  case kiloampereHours
  case ampereHours
  case milliampereHours
  case microampereHours
  case megaamperes
  case kiloamperes
  case amperes
  case milliamperes
  case microamperes
  case megavolts
  case kilovolts
  case volts
  case millivolts
  case microvolts
  case megaohms
  case kiloohms
  case ohms
  case milliohms
  case microohms
  case siemens
  case kilosiemens
  case megasiemens
  case millisiemens
  case microsiemens
  case henrys
  case kilohenrys
  case megahenrys
  case millihenrys
  case microhenrys
  case farads
  case kilofarads
  case megafarads
  case millifarads
  case microfarads
  case webers
  case kilowebers
  case megawebers
  case milliwebers
  case microwebers
  case teslas
  case kiloteslas
  case megateslas
  case milliteslas
  case microteslas
  case bytes
  case bits
  case nibbles
  case yottabytes
  case zettabytes
  case exabytes
  case petabytes
  case terabytes
  case gigabytes
  case megabytes
  case kilobytes
  case yottabits
  case zettabits
  case exabits
  case petabits
  case terabits
  case gigabits
  case megabits
  case kilobits
  case yobibytes
  case zebibytes
  case exbibytes
  case pebibytes
  case tebibytes
  case gibibytes
  case mebibytes
  case kibibytes
  case yobibits
  case zebibits
  case exbibits
  case pebibits
  case tebibits
  case gibibits
  case mebibits
  case kibibits
  case bytesPerSecond
  case bitsPerSecond
  case yottabytesPerSecond
  case zettabytesPerSecond
  case exabytesPerSecond
  case petabytesPerSecond
  case terabytesPerSecond
  case gigabytesPerSecond
  case megabytesPerSecond
  case kilobytesPerSecond
  case yottabitsPerSecond
  case zettabitsPerSecond
  case exabitsPerSecond
  case petabitsPerSecond
  case terabitsPerSecond
  case gigabitsPerSecond
  case megabitsPerSecond
  case kilobitsPerSecond
  case yobibytesPerSecond
  case zebibytesPerSecond
  case exbibytesPerSecond
  case pebibytesPerSecond
  case tebibytesPerSecond
  case gibibytesPerSecond
  case mebibytesPerSecond
  case kibibytesPerSecond
  case yobibitsPerSecond
  case zebibitsPerSecond
  case exbibitsPerSecond
  case pebibitsPerSecond
  case tebibitsPerSecond
  case gibibitsPerSecond
  case mebibitsPerSecond
  case kibibitsPerSecond
  case currencyADA
  case currencyTON
  case currencyLINK
  case currencyUNI
  case currencyAED
  case currencyAFN
  case currencyALL
  case currencyAMD
  case currencyANG
  case currencyAOA
  case currencyARS
  case currencyAUD
  case currencyAWG
  case currencyAZN
  case currencyBAM
  case currencyBBD
  case currencyBCH
  case currencyBDT
  case currencyBGN
  case currencyBHD
  case currencyBIF
  case currencyBMD
  case currencyBNB
  case currencyBND
  case currencyBOB
  case currencyBRL
  case currencyBSD
  case currencyBSV
  case currencyBTC
  case currencyBTN
  case currencyBWP
  case currencyBYN
  case currencyBZD
  case currencyCAD
  case currencyCDF
  case currencyCHF
  case currencyCLF
  case currencyCLP
  case currencyCNY
  case currencyCOP
  case currencyCRC
  case currencyCUC
  case currencyCVE
  case currencyCZK
  case currencyDASH
  case currencyDJF
  case currencyDKK
  case currencyDOGE
  case currencyDOP
  case currencyDZD
  case currencyEGP
  case currencyEOS
  case currencyERN
  case currencyETB
  case currencyETC
  case currencyETH
  case currencyEUR
  case currencyFJD
  case currencyFKP
  case currencyGBP
  case currencyGEL
  case currencyGGP
  case currencyGHS
  case currencyGIP
  case currencyGMD
  case currencyGNF
  case currencyGTQ
  case currencyGYD
  case currencyHKD
  case currencyHNL
  case currencyHRK
  case currencyHTG
  case currencyHUF
  case currencyIDR
  case currencyILS
  case currencyIMP
  case currencyINR
  case currencyIQD
  case currencyIRR
  case currencyISK
  case currencyJEP
  case currencyJMD
  case currencyJOD
  case currencyJPY
  case currencyKES
  case currencyKGS
  case currencyKHR
  case currencyKMF
  case currencyKPW
  case currencyKRW
  case currencyKWD
  case currencyKYD
  case currencyKZT
  case currencyLAK
  case currencyLBP
  case currencyLKR
  case currencyLRD
  case currencyLSL
  case currencyLTC
  case currencyLTL
  case currencyLVL
  case currencyLYD
  case currencyMAD
  case currencyMDL
  case currencyMGA
  case currencyMKD
  case currencyMMK
  case currencyMNT
  case currencyMOP
  case currencyMRU
  case currencyMUR
  case currencyMVR
  case currencyMWK
  case currencyMXN
  case currencyMYR
  case currencyMZN
  case currencyNAD
  case currencyNEO
  case currencyNGN
  case currencyNIO
  case currencyNOK
  case currencyNPR
  case currencyNZD
  case currencyOMR
  case currencyPAB
  case currencyPEN
  case currencyPGK
  case currencyPHP
  case currencyPKR
  case currencyPLN
  case currencyPYG
  case currencyQAR
  case currencyRON
  case currencyRSD
  case currencyRUB
  case currencyRWF
  case currencySAR
  case currencySBD
  case currencySCR
  case currencySDG
  case currencySEK
  case currencySGD
  case currencySHP
  case currencySLL
  case currencySOS
  case currencySOL
  case currencyAVAX
  case currencyLUNA
  case currencyDOT
  case currencyPOL
  case currencySHIB
  case currencySRD
  case currencySTD
  case currencySVC
  case currencySYP
  case currencySZL
  case currencyTHB
  case currencyTJS
  case currencyTMT
  case currencyTND
  case currencyTOP
  case currencyTRX
  case currencyTRY
  case currencyTTD
  case currencyTWD
  case currencyTZS
  case currencyUAH
  case currencyUGX
  case currencyUSD
  case currencyUSDT
  case currencyUYU
  case currencyUZS
  case currencyVES
  case currencyVND
  case currencyVUV
  case currencyWST
  case currencyXAF
  case currencyXAG
  case currencyXAU
  case currencyXCD
  case currencyXDR
  case currencyXLM
  case currencyXMR
  case currencyXOF
  case currencyXPF
  case currencyXRP
  case currencyYER
  case currencyZAR
  case currencyZMK
  case currencyZMW
  case currencyZWL
  case currencySatoshi
  case currencyWei
  case currencyGwei
  case currencyDollarCents
  case currencyBritishPence
  case currencyEuroCents
  case undefined
  public var unit: SoulverCore.SCUnit {
    get
  }
  public var unitType: SoulverCore.UnitType {
    get
  }
  public var motherUnitIdentifier: SoulverCore.UnitIdentifier {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias AllCases = [SoulverCore.UnitIdentifier]
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [SoulverCore.UnitIdentifier] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public typealias LineIndex = Swift.Int
public struct Place {
  public enum PlaceType : Swift.Equatable, Swift.Hashable {
    case country(country: SoulverCore.Country)
    case city(city: SoulverCore.City)
    case airport(airport: SoulverCore.Airport)
    case timeZoneAbbreviation
    case custom(customPlace: SoulverCore.CustomPlace)
    case unspecified
    public static func == (a: SoulverCore.Place.PlaceType, b: SoulverCore.Place.PlaceType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(name: Swift.String, aliases: [Swift.String]?, timeZone: Foundation.TimeZone, type: SoulverCore.Place.PlaceType = .unspecified)
  public let name: Swift.String
  public let aliases: [Swift.String]?
  public let timeZone: Foundation.TimeZone
  public let type: SoulverCore.Place.PlaceType
}
extension SoulverCore.Place : Swift.Hashable, Swift.Equatable {
  public static func == (a: SoulverCore.Place, b: SoulverCore.Place) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension SoulverCore.Place {
  public var city: Swift.String? {
    get
  }
  public var country: Swift.String? {
    get
  }
  public var countryCode: Swift.String? {
    get
  }
  public var gpsCoordinates: SoulverCore.GPSCoordinates? {
    get
  }
}
public typealias RawExpression = Swift.String
public struct Airport {
  public let name: Swift.String
  public let iata_code: Swift.String
}
extension SoulverCore.Airport : Swift.Codable, Swift.Hashable, Swift.Equatable {
  public static func == (a: SoulverCore.Airport, b: SoulverCore.Airport) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@_hasMissingDesignatedInitializers public class SCUnit : Swift.Equatable, Swift.Hashable, @unchecked Swift.Sendable, Swift.CustomDebugStringConvertible {
  final public let identifier: SoulverCore.UnitIdentifier
  final public let symbol: Swift.String
  public var baseUnitValue: Foundation.Decimal {
    get
  }
  public var baseUnit: SoulverCore.SCUnit {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: SoulverCore.SCUnit, rhs: SoulverCore.SCUnit) -> Swift.Bool
  open class func baseUnit() -> SoulverCore.SCUnit
  public var debugDescription: Swift.String {
    get
  }
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
extension SoulverCore.SCUnit {
  public var unitType: SoulverCore.UnitType {
    get
  }
}
public enum UnitMeasurementSystem : Swift.String, Swift.RawRepresentable, Swift.Equatable, Swift.CaseIterable {
  case customaryUS
  case imperial
  case metric
  public init?(rawValue: Swift.String)
  public typealias AllCases = [SoulverCore.UnitMeasurementSystem]
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [SoulverCore.UnitMeasurementSystem] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public enum SIThreshold : Swift.String, Swift.Sendable {
  case pentillion
  case septillion
  case sextillion
  case quintillion
  case quadrillion
  case trillion
  case billion
  case million
  case hundredThousand
  case thousand
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct UnitRate {
  public let value: Foundation.Decimal
  public let ofUnit: SoulverCore.SCUnit?
  public let perUnit: SoulverCore.SCUnit
}
extension SoulverCore.UnitRate : Swift.Comparable {
  public static func < (lhs: SoulverCore.UnitRate, rhs: SoulverCore.UnitRate) -> Swift.Bool
  public static func == (a: SoulverCore.UnitRate, b: SoulverCore.UnitRate) -> Swift.Bool
}
extension SoulverCore.UnitRate : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension SoulverCore.UnitExpression : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public struct CommentingOptions : Swift.Hashable, Swift.Equatable {
  public init(bracketComments: Swift.Bool = true, quotationMarkComments: Swift.Bool = true, trailingComments: Swift.Bool = true, labelComments: Swift.Bool = true, hashTags: Swift.Bool = true)
  public var bracketComments: Swift.Bool
  public var quotationMarkComments: Swift.Bool
  public var trailingComments: Swift.Bool
  public var labelComments: Swift.Bool
  public var hashTags: Swift.Bool
  public static var all: SoulverCore.CommentingOptions {
    get
  }
  public static var none: SoulverCore.CommentingOptions {
    get
  }
  public static func == (a: SoulverCore.CommentingOptions, b: SoulverCore.CommentingOptions) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
final public class Calculator : @unchecked Swift.Sendable {
  final public var customization: SoulverCore.EngineCustomization {
    get
  }
  public init(customization: SoulverCore.EngineCustomization)
  final public func calculate(_ expression: SoulverCore.RawExpression, with variableList: SoulverCore.VariableList? = nil) -> SoulverCore.CalculationResult
  final public func calculateInBackground(_ expression: SoulverCore.RawExpression, with variableList: SoulverCore.VariableList? = nil) async -> SoulverCore.CalculationResult
  final public var formattingPreferences: SoulverCore.FormattingPreferences?
  @objc deinit
}
extension SoulverCore.Calculator {
  public static var basic: SoulverCore.Calculator {
    get
  }
}
public struct Multiplier : Swift.Equatable {
  public let decimalValue: Foundation.Decimal
  public static func == (a: SoulverCore.Multiplier, b: SoulverCore.Multiplier) -> Swift.Bool
}
public class EvaluationResultFormatter {
  public init(customization: SoulverCore.EngineCustomization, formattingPreferences: SoulverCore.FormattingPreferences?)
  public func format(result: SoulverCore.EvaluationResult) -> SoulverCore.CalculationResult
  @objc deinit
}
@_hasMissingDesignatedInitializers public class LineCollectionTrimmer {
  public class func trimmingTokensOfTypes(_ tokenTypeSet: SoulverCore.TokenTypeSet, from lineCollection: SoulverCore.LineCollection) -> SoulverCore.LineCollection
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class LineSheet : Swift.Codable, @unchecked Swift.Sendable {
  final public var copy: SoulverCore.LineSheet {
    get
  }
  final public subscript(index: SoulverCore.LineIndex) -> SoulverCore.Line {
    get
    set
  }
  required public init(from decoder: any Swift.Decoder) throws
  final public func encode(to encoder: any Swift.Encoder) throws
  final public var debugDescription: Swift.String {
    get
  }
  @objc deinit
}
extension SoulverCore.LineSheet : Swift.Equatable, Swift.Hashable {
  public static func == (lhs: SoulverCore.LineSheet, rhs: SoulverCore.LineSheet) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
extension SoulverCore.LineSheet {
  final public var text: Swift.String {
    get
  }
}
public struct LineSheetDelta {
  public let indexesAdded: Foundation.IndexSet
  public let indexesDeleted: Foundation.IndexSet
  public let indexesModified: Foundation.IndexSet
  public var isSingleLineEdit: Swift.Bool {
    get
  }
}
@_Concurrency.MainActor public class LineCollectionEditingHelper {
  @_Concurrency.MainActor final public let lineCollection: SoulverCore.LineCollection
  @_Concurrency.MainActor public init(lineCollection: SoulverCore.LineCollection, textView: any SoulverCore.CalculationTextView)
  @_Concurrency.MainActor public func beginEdit(with proposedTextViewEdit: SoulverCore.TextViewEditProposal)
  public typealias DependentLinesEvaluatedHandler = (_ evaluatedDependentIndexes: Foundation.IndexSet) -> Swift.Void
  @_Concurrency.MainActor public func finalizeEdit() -> SoulverCore.LineCollectionIndexDiff
  @_Concurrency.MainActor public func processDependenciesOn(linesInChange: SoulverCore.LineCollectionIndexDiff) async -> Foundation.IndexSet
  @_Concurrency.MainActor public func convert(localRange: Swift.Range<Swift.String.Index>, toTextRangeOn lineIndex: SoulverCore.LineIndex) -> Swift.Range<Swift.String.Index>?
  @_Concurrency.MainActor public func rangeOfLineAtIndex(_ lineIndex: SoulverCore.LineIndex) -> Swift.Range<Swift.String.Index>?
  @objc deinit
}
public protocol CalculationTextView : AnyObject {
  var text: Swift.String { get }
}
public struct TextViewEditProposal {
  public init(ranges: [Swift.Range<Swift.String.Index>], replacements: [Swift.String])
}
public struct LineCollectionIndexDiff : Swift.Sendable {
  public let indexesAdded: Foundation.IndexSet
  public let indexesRemoved: Foundation.IndexSet
  public let indexesEdited: Foundation.IndexSet
  public var lineCountDidChange: Swift.Bool {
    get
  }
  public var indexesEvaluated: Foundation.IndexSet {
    get
  }
}
public struct CustomFunctionParameter {
  public let subsheet: SoulverCore.Subsheet
  public let matchedToken: SoulverCore.Token
}
public class CustomFunctionDefinitionUtility {
  public init(customization: SoulverCore.EngineCustomization)
  public func parametersIn(customFunctionDefinition: SoulverCore.RawExpression) -> [SoulverCore.CustomFunctionParameter]?
  public func prototypeExpressionFrom(customFunctionDefinition: SoulverCore.RawExpression) -> SoulverCore.PrototypeExpression?
  public func customFunctionFrom(customFunctionDefinition: SoulverCore.RawExpression, implementationBody: SoulverCore.LineSheet) -> SoulverCore.CustomFunction?
  @objc deinit
}
public struct LineCollectionArchive : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@_hasMissingDesignatedInitializers public class LineCollectionArchiver {
  public class func encode(lineCollection: SoulverCore.LineCollection) throws -> Foundation.Data
  public class func decode(encodedLineSheet: Foundation.Data, withCustomization customization: SoulverCore.EngineCustomization, preferredLocale locale: Foundation.Locale, defaultLineFormatting: SoulverCore.FormattingPreferences?, baseVariables: SoulverCore.VariableList?, evaluate: Swift.Bool = true) throws -> SoulverCore.LineCollection
  public class func archiveFor(lineCollection: SoulverCore.LineCollection) -> SoulverCore.LineCollectionArchive
  public class func lineCollectionFrom(archive: SoulverCore.LineCollectionArchive, withCustomization customization: SoulverCore.EngineCustomization, preferredLocale locale: Foundation.Locale) -> SoulverCore.LineCollection
  @objc deinit
}
public struct ExpressionBeautificationOptions {
  public var quickOperators: Swift.Bool
  public var autoThousandsSeparators: Swift.Bool
  public var allowsOrphanedThousandsSeparators: Swift.Bool
  public var padStandardOperators: Swift.Bool
  public var padSlashOperatorWhereNecessary: Swift.Bool
  public var fancyTimes: Swift.Bool
  public var fancyMinus: Swift.Bool
  public var collapseSpaces: Swift.Bool
  public var formatsSlashCommentsWithSpaces: Swift.Bool
  public var useNonBreakingSpacesInMultiwordVariables: Swift.Bool
  public static var defaults: SoulverCore.ExpressionBeautificationOptions {
    get
  }
  public init()
}
@_hasMissingDesignatedInitializers public class LineCollectionCompletions {
  public class func completionsFor(textFragment: Swift.String, charIndex: Swift.Int, onLineAtIndex lineIndex: SoulverCore.LineIndex, in lineCollection: SoulverCore.LineCollection) -> [Swift.String]
  @objc deinit
}
@_hasMissingDesignatedInitializers public class LineCollectionEnumerator {
  public typealias EnumerationExpression = Swift.String
  public typealias EnumerationResult = Swift.String
  public enum ReferenceSubstituionPolicy {
    case dontSubstitue
    case formattedResult
    case plainTextReference
    case markdownLinkStyle
    public static func == (a: SoulverCore.LineCollectionEnumerator.ReferenceSubstituionPolicy, b: SoulverCore.LineCollectionEnumerator.ReferenceSubstituionPolicy) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum ResultFormatting {
    case formatted
    case raw
    public static func == (a: SoulverCore.LineCollectionEnumerator.ResultFormatting, b: SoulverCore.LineCollectionEnumerator.ResultFormatting) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct LineCollectionEnumerationOptions {
    public var referenceSubstitutionPolicy: SoulverCore.LineCollectionEnumerator.ReferenceSubstituionPolicy
    public var resultFormatting: SoulverCore.LineCollectionEnumerator.ResultFormatting
    public var reversed: Swift.Bool
    public init()
  }
  public typealias LineCollectionStringEnumerationHandler = (SoulverCore.LineIndex, SoulverCore.LineCollectionEnumerator.EnumerationExpression, SoulverCore.LineCollectionEnumerator.EnumerationResult, inout Swift.Bool) -> Swift.Void
  public typealias LineCollectionModelEnumerationHandler = (SoulverCore.LineIndex, SoulverCore.TokenList, SoulverCore.CalculationResult?, inout Swift.Bool) -> Swift.Void
  public class func enumerateStringsIn(lineCollection: SoulverCore.LineCollection, with options: SoulverCore.LineCollectionEnumerator.LineCollectionEnumerationOptions = LineCollectionEnumerationOptions(), in handler: (SoulverCore.LineIndex, SoulverCore.LineCollectionEnumerator.EnumerationExpression, SoulverCore.LineCollectionEnumerator.EnumerationResult, inout Swift.Bool) -> Swift.Void)
  public class func enumerateModelsIn(lineCollection: SoulverCore.LineCollection, with options: SoulverCore.LineCollectionEnumerator.LineCollectionEnumerationOptions = LineCollectionEnumerationOptions(), in modelHandler: (SoulverCore.LineIndex, SoulverCore.TokenList, SoulverCore.CalculationResult?, inout Swift.Bool) -> Swift.Void)
  public class func enumerateStringsIn<T>(lineCollection: SoulverCore.LineCollection, with options: SoulverCore.LineCollectionEnumerator.LineCollectionEnumerationOptions = LineCollectionEnumerationOptions(), in handler: (SoulverCore.LineIndex, SoulverCore.LineCollectionEnumerator.EnumerationExpression, SoulverCore.LineCollectionEnumerator.EnumerationResult) -> T?) -> T?
  @objc deinit
}
public let UntokenizedLineReference: Swift.String
public struct Subsheet : Swift.Hashable, Swift.Equatable, Swift.Codable {
  public enum SubsheetEvaluatorType : Swift.String, Swift.Codable {
    case soulverCore
    case javascript
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public let lineSheet: SoulverCore.LineSheet
  public let identifier: SoulverCore.LineReference
  public let evaluator: SoulverCore.Subsheet.SubsheetEvaluatorType
  public var canReferenceVariablesOutsideBody: Swift.Bool
  public static func == (lhs: SoulverCore.Subsheet, rhs: SoulverCore.Subsheet) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
}
extension SoulverCore.Subsheet {
  public var stringValue: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers public class LineCollectionExporter {
  public struct ExportOptions {
    public var plainTextSeparator: Swift.String
    public var useUnformattedResults: Swift.Bool
    public var substituteLineReferences: Swift.Bool
    public var includeAnswers: Swift.Bool
    public init()
  }
  public class func jsonDataFor(lineCollection: SoulverCore.LineCollection) -> Foundation.Data?
  public class func textFor(lineCollection: SoulverCore.LineCollection, options: SoulverCore.LineCollectionExporter.ExportOptions = ExportOptions()) -> Swift.String
  @objc deinit
}
extension SoulverCore.Subsheet : SoulverCore.DynamicVariable {
  public var evaluatedResult: SoulverCore.EvaluationResult? {
    get
  }
}
@_hasMissingDesignatedInitializers public class LineCollectionFuser {
  public class func fusingTokensOfTypes(_ tokenTypeSet: SoulverCore.TokenTypeSet, from lineCollection: SoulverCore.LineCollection) -> SoulverCore.LineCollection
  @objc deinit
}
@_hasMissingDesignatedInitializers public class ResultContextualMetadata {
  public class func humanReadableMetadataFor(formattedResult: SoulverCore.CalculationResult, customization: SoulverCore.EngineCustomization) -> Swift.String?
  @objc deinit
}
public class LineCollectionReducer {
  public var inflectCustomUnits: Swift.Bool
  public init(lineCollection: SoulverCore.LineCollection)
  public var returnValue: SoulverCore.CalculationResult {
    get
  }
  public var locallyDefinedVariables: [SoulverCore.Variable] {
    get
  }
  public var locallyDefinedUnits: [SoulverCore.CustomUnit] {
    get
  }
  public struct CustomDefinitions {
    public let customVariables: [SoulverCore.Variable]
    public let customUnits: [SoulverCore.CustomUnit]
    public let inflectedCustomUnits: [SoulverCore.CustomUnit]
    public let customPlaces: [SoulverCore.Place]
    public let customFunctions: [SoulverCore.CustomFunction]
  }
  public var customDefinitions: SoulverCore.LineCollectionReducer.CustomDefinitions {
    get
  }
  @objc deinit
}
final public class LineCollection : @unchecked Swift.Sendable {
  public typealias EvaluatedLinesHandler = (_ evaluatedIndexes: Foundation.IndexSet) -> Swift.Void
  final public var customization: SoulverCore.EngineCustomization {
    get
  }
  final public var lineSheet: SoulverCore.LineSheet {
    get
    set
  }
  final public var variableList: SoulverCore.VariableList? {
    get
    set
  }
  final public var defaultLineFormattingPreferences: SoulverCore.FormattingPreferences? {
    get
    set
  }
  final public var expressionBeautificationOptions: SoulverCore.ExpressionBeautificationOptions? {
    get
    set
  }
  final public var commentingOptions: SoulverCore.CommentingOptions {
    get
    set
  }
  public init(customization: SoulverCore.EngineCustomization)
  final public var deepCopy: SoulverCore.LineCollection {
    get
  }
  final public func beginChanges()
  final public func endChangesWith(evaluationHandler: SoulverCore.LineCollection.EvaluatedLinesHandler?, dependenciesHandler: SoulverCore.LineCollection.EvaluatedLinesHandler?)
  @discardableResult
  final public func addLine(_ expression: Swift.String = "") -> SoulverCore.Line
  final public func setLinesWithExpressions(_ expressions: [SoulverCore.RawExpression])
  final public func insertLineBelow(lineIndex: SoulverCore.LineIndex, with expression: Swift.String)
  final public func insertLineAt(lineIndex: SoulverCore.LineIndex, with expression: Swift.String)
  final public func insert(line: SoulverCore.Line, at lineIndex: SoulverCore.LineIndex)
  final public func moveLineAt(lineIndex: SoulverCore.LineIndex, toLineIndex: SoulverCore.LineIndex)
  final public func removeLineAt(lineIndex: SoulverCore.LineIndex)
  final public func replaceLineAt(lineIndex: SoulverCore.LineIndex, with newLine: SoulverCore.Line)
  final public subscript(index: SoulverCore.LineIndex) -> SoulverCore.Line {
    get
    set(newValue)
  }
  final public subscript(safe index: SoulverCore.LineIndex) -> SoulverCore.Line? {
    get
  }
  final public func setExpression(expression: Swift.String, forLineAt index: SoulverCore.LineIndex)
  final public func setFormatting(formattingPreferences: SoulverCore.FormattingPreferences)
  final public func setFormatting(formattingPreferences: SoulverCore.FormattingPreferences?, forLineAt index: SoulverCore.LineIndex)
  final public func setAlignment(alignment: SoulverCore.Line.ExpressionAlignment, forLineAt index: SoulverCore.LineIndex)
  final public func setHighlight(color: SoulverCore.Line.HighlightColor?, for portion: SoulverCore.Line.HighlightPortion, forLineAt index: SoulverCore.LineIndex)
  final public func setAttribution(attribution: Swift.String?, forLineAt index: SoulverCore.LineIndex)
  final public func set(isGrandTotal: Swift.Bool, forLineAt index: SoulverCore.LineIndex)
  final public func setBehaviour(behaviour: SoulverCore.Line.CalculationBehaviour, forLineAt index: SoulverCore.LineIndex)
  final public func setTransformer(reference: SoulverCore.LineReference?, forLineAt index: SoulverCore.LineIndex)
  final public func cancelPendingAnswer(forLineAt lineIndex: SoulverCore.LineIndex)
  final public func evaluateAll()
  @discardableResult
  final public func evaluateLinesAt(indexes: Foundation.IndexSet, dependenciesUpdatedHandler: SoulverCore.LineCollection.EvaluatedLinesHandler? = nil) -> Foundation.IndexSet
  @discardableResult
  final public func makeReferenceForLineAt(lineIndex: SoulverCore.LineIndex) -> SoulverCore.LineReference
  final public func clearReferenceForLineAt(lineIndex: SoulverCore.LineIndex)
  public static var previousLineReference: SoulverCore.LineReference {
    get
  }
  @discardableResult
  final public func observeEvaluationWith(handler: @escaping SoulverCore.LineCollection.EvaluatedLinesHandler) -> SoulverCore.LineCollection.LineCollectionObserverToken
  final public func remove(observer: SoulverCore.LineCollection.LineCollectionObserverToken)
  final public var includeVariablesReferencingPreviousLine: Swift.Bool {
    get
    set
  }
  final public var includeVariablesReferencingLineNumbers: Swift.Bool {
    get
    set
  }
  final public var rawStringVariableDefinitions: Swift.Bool {
    get
    set
  }
  final public var unitDeclarations: Swift.Bool {
    get
    set
  }
  final public var remoteQueries: Swift.Bool {
    get
    set
  }
  final public var contextualDatespans: Swift.Bool {
    get
    set
  }
  final public var tripPlanning: Swift.Bool {
    get
    set
  }
  final public var grandTotals: Swift.Bool {
    get
  }
  final public var generateVariablesFromLabels: Swift.Bool {
    get
    set
  }
  final public func calculateQuickStatistic(statisticType: SoulverCore.StatisticType, limitToIndexes: Foundation.IndexSet? = nil, ignoreVariableDeclaration: Swift.Bool = true, ignoreReferencedLines: Swift.Bool = true) -> SoulverCore.CalculationResult?
  final public var quickSum: SoulverCore.CalculationResult? {
    get
  }
  final public var quickAverage: SoulverCore.CalculationResult? {
    get
  }
  final public var quickCount: SoulverCore.CalculationResult? {
    get
  }
  final public func quickSumOf(indexes: Foundation.IndexSet) -> SoulverCore.CalculationResult?
  final public func quickAverageOf(indexes: Foundation.IndexSet) -> SoulverCore.CalculationResult?
  final public func quickCountOf(indexes: Foundation.IndexSet) -> SoulverCore.CalculationResult?
  @discardableResult
  final public func convertToLocale(_ toLocale: Foundation.Locale) -> Swift.Bool
  final public func set(customization: SoulverCore.EngineCustomization)
  final public func performChanges(performBlock: (SoulverCore.LineCollection) -> Swift.Void) -> SoulverCore.LineCollection.LineCollectionStateTicket
  @discardableResult
  final public func revertToStateWith(ticket: SoulverCore.LineCollection.LineCollectionStateTicket) -> SoulverCore.LineSheetDelta?
  final public func clearStates()
  final public var lineCount: Swift.Int {
    get
  }
  final public func isValidIndex(_ lineIndex: SoulverCore.LineIndex) -> Swift.Bool
  final public func areValidIndexes(_ indexes: Foundation.IndexSet) -> Swift.Bool
  final public func subtotalIndexFor(lineIndex: SoulverCore.LineIndex) -> SoulverCore.LineIndex?
  final public var allIndexes: Foundation.IndexSet {
    get
  }
  final public var lastIndex: Swift.Int {
    get
  }
  final public var firstIndex: Swift.Int {
    get
  }
  final public var isEmpty: Swift.Bool {
    get
  }
  final public var lines: [SoulverCore.Line] {
    get
  }
  final public func linesAtIndexes(indexes: Foundation.IndexSet) -> [SoulverCore.Line]
  final public func variableStateOnLine(_ lineIndex: SoulverCore.LineIndex) -> SoulverCore.VariableList
  final public var finalVariableState: SoulverCore.VariableList {
    get
  }
  final public func resultsAsVariableWith(title: Swift.String, statistic: SoulverCore.StatisticType?) -> SoulverCore.Variable
  final public func tokenFor(tokenIndexPath: SoulverCore.TokenIndexPath) -> SoulverCore.Token?
  final public func indexPathFor(token: SoulverCore.Token, onLineAt lineIndex: SoulverCore.LineIndex) -> SoulverCore.TokenIndexPath?
  final public func isValidLineReference(UID: SoulverCore.UID, onLineAt lineIndex: SoulverCore.LineIndex) -> Swift.Bool
  final public func indexOfFirstNonEmptyLineAbove(index: SoulverCore.LineIndex) -> SoulverCore.LineIndex?
  final public func lineForLineReference(lineReference: SoulverCore.LineReference) -> SoulverCore.Line?
  final public func lineFor(_ variable: SoulverCore.Variable) -> SoulverCore.Line?
  final public func formattedDefinitionOf(inlineVariable: SoulverCore.Variable) -> Swift.String?
  @discardableResult
  final public func replaceOccurancesInExpressions(replacements: [Swift.String : Swift.String], forTypes: Swift.Set<SoulverCore.TokenType>? = nil) -> Foundation.IndexSet
  final public func unformattedResultFor(lineIndex: SoulverCore.LineIndex) -> Swift.String
  final public func append(otherLineCollection: SoulverCore.LineCollection)
  final public var subsheetCount: Swift.Int {
    get
  }
  @discardableResult
  final public func addSubsheet(evaluator: SoulverCore.Subsheet.SubsheetEvaluatorType = .soulverCore, canReferenceVariablesOutsideBody: Swift.Bool = true) -> SoulverCore.LineReference
  final public func subsheetWith(reference: SoulverCore.LineReference) -> SoulverCore.Subsheet?
  final public func set(content lineSheet: SoulverCore.LineSheet, forSubsheetWith reference: SoulverCore.LineReference)
  @objc deinit
}
extension SoulverCore.LineCollection : Swift.CustomDebugStringConvertible {
  public typealias MultiLineText = Swift.String
  final public class func textViewReadyLineCollectionWith(customization: SoulverCore.EngineCustomization) -> SoulverCore.LineCollection
  convenience public init(multiLineText: SoulverCore.LineCollection.MultiLineText, customization: SoulverCore.EngineCustomization? = nil)
  public static var basic: SoulverCore.LineCollection {
    get
  }
  final public var debugDescription: Swift.String {
    get
  }
}
extension SoulverCore.LineCollection {
  public typealias LineCollectionStateTicket = Swift.String
  @_hasMissingDesignatedInitializers public class LineCollectionObserverToken : Swift.Hashable, Swift.Equatable {
    public static func == (lhs: SoulverCore.LineCollection.LineCollectionObserverToken, rhs: SoulverCore.LineCollection.LineCollectionObserverToken) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension SoulverCore.LineCollection {
  final public var indexesOfTimeDependentLines: Foundation.IndexSet {
    get
  }
  final public func indexesOfLinesDependentOn(variables: [SoulverCore.Variable]) -> Foundation.IndexSet
  final public var indexesOfPendingLines: Foundation.IndexSet {
    get
  }
}
@_hasMissingDesignatedInitializers public class LineCollectionIterator : Swift.IteratorProtocol {
  public typealias Element = SoulverCore.Line
  public func next() -> SoulverCore.Line?
  @objc deinit
}
extension SoulverCore.LineCollection : Swift.Sequence {
  final public func makeIterator() -> SoulverCore.LineCollectionIterator
  public typealias Element = SoulverCore.LineCollectionIterator.Element
  public typealias Iterator = SoulverCore.LineCollectionIterator
}
extension SoulverCore.LineCollection {
  final public var text: SoulverCore.LineCollection.MultiLineText {
    get
  }
}
public struct Line : Swift.Codable, Swift.Identifiable, Swift.Sendable {
  public var expression: Swift.String
  public var behaviour: SoulverCore.Line.CalculationBehaviour
  public var lineReference: SoulverCore.LineReference?
  public var formattingPreferences: SoulverCore.FormattingPreferences?
  public var expressionAlignment: SoulverCore.Line.ExpressionAlignment
  public var result: SoulverCore.CalculationResult?
  public var parsedExpression: SoulverCore.TokenList?
  public var apparentLineType: SoulverCore.Line.ApparentLineType?
  public var lineIndex: SoulverCore.LineIndex?
  public var variableEnvironment: SoulverCore.VariableList?
  public var id: Foundation.UUID {
    get
  }
  public var rawResult: Swift.String {
    get
  }
  public var formattedResult: Swift.String {
    get
  }
  public var referencableResult: SoulverCore.CalculationResult? {
    get
  }
  public var attribution: Swift.String? {
    get
  }
  public init(_ expression: SoulverCore.RawExpression)
  public init()
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public enum CalculationBehaviour : Swift.String, Swift.Codable, Swift.Sendable {
    case evaluatesExpression
    case definesFunction
    case tripWaypoint
    case sumsLinesAbove
    case startRunningTotal
    case startRunningBudget
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum ExpressionAlignment : Swift.String, Swift.Codable, Swift.Sendable {
    case left
    case center
    case right
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum ApparentLineType : Swift.Sendable {
    case regular
    case comment
    case header
    case variableDeclaration
    case divider
    case assertion
    public static func == (a: SoulverCore.Line.ApparentLineType, b: SoulverCore.Line.ApparentLineType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum HighlightColor : Swift.String, Swift.Codable, Swift.RawRepresentable, Swift.Sendable, Swift.Equatable, Swift.Hashable {
    case orange
    case mint
    case blue
    case purple
    case pink
    case red
    case yellow
    case green
    case grey
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum HighlightPortion : Swift.String, Swift.Codable, Swift.Sendable, Swift.Equatable, Swift.Hashable, Swift.CaseIterable {
    case head
    case body
    case tail
    public init?(rawValue: Swift.String)
    public typealias AllCases = [SoulverCore.Line.HighlightPortion]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [SoulverCore.Line.HighlightPortion] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  public func highlightColorFor(portion: SoulverCore.Line.HighlightPortion) -> SoulverCore.Line.HighlightColor?
  public mutating func set(color: SoulverCore.Line.HighlightColor?, for portion: SoulverCore.Line.HighlightPortion)
  public typealias ID = Foundation.UUID
}
extension SoulverCore.Line {
  public var isSubtotal: Swift.Bool {
    get
  }
  public var isGrandSubtotal: Swift.Bool {
    get
  }
  public var startsRunningTotal: Swift.Bool {
    get
  }
  public var startsRunningBudget: Swift.Bool {
    get
  }
  public var isWaypoint: Swift.Bool {
    get
  }
  public var isPartOfTrip: Swift.Bool {
    get
  }
  public var isPartOfRunningStatistic: Swift.Bool {
    get
  }
  public var isHeading: Swift.Bool {
    get
  }
  public var isDivider: Swift.Bool {
    get
  }
}
extension SoulverCore.Line {
  public var declaredVariable: SoulverCore.Variable? {
    get
  }
  public func referencesInExpressionTo(variable: SoulverCore.Variable) -> [SoulverCore.Token]
  public var indexesReferencedInExpression: Foundation.IndexSet {
    get
  }
}
extension SoulverCore.Line : Swift.Equatable, Swift.Hashable {
  public static func == (a: SoulverCore.Line, b: SoulverCore.Line) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension SoulverCore.Line : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public enum ConverterIdentifier : Swift.String, Swift.CaseIterable, Swift.RawRepresentable, Swift.Sendable {
  case toUnit
  case toCurrencyWithExplicitRate
  case toUnitExpression
  case toRate
  case toSimplifiedRate
  case toPercentage
  case applyPercentage
  case toTimezone
  case toFraction
  case toMultiplier
  case toScientificNotation
  case toBinary
  case toDecimal
  case toOctal
  case toHexadecimal
  case toBaseX
  case toDate
  case toTimespan
  case toLaptime
  case toTimestamp
  case toISO8601
  case toDateFormatWithTemplate
  case toFrequency
  case toPitch
  case toMIDI
  case roundedUpToNearestX
  case roundedDownToNearestX
  case roundedToNearestX
  case roundedDown
  case roundedUp
  case roundedToDp
  case rounded
  case toFrequencyRate
  case toDMS
  case toFrametime
  case daysAndHours
  case hoursAndMinutes
  case minutesAndSeconds
  case monthsAndDays
  case monthsAndWeeks
  case weeksAndDays
  case yearsAndMonths
  case poundsAndOunces
  case feetAndInches
  case unknown
  public init?(rawValue: Swift.String)
  public typealias AllCases = [SoulverCore.ConverterIdentifier]
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [SoulverCore.ConverterIdentifier] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
extension SoulverCore.ConverterIdentifier : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
public protocol Keyword : Swift.CaseIterable, Swift.RawRepresentable, Swift.Sendable where Self.RawValue == Swift.String {
  var aliases: [Swift.String]? { get }
}
extension SoulverCore.Keyword {
  public var aliases: [Swift.String]? {
    get
  }
}
@_hasMissingDesignatedInitializers final public class TokenList {
  final public var tokens: [SoulverCore.Token]
  @objc deinit
}
extension SoulverCore.TokenList : Swift.Equatable, Swift.Hashable {
  public static func == (lhs: SoulverCore.TokenList, rhs: SoulverCore.TokenList) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
extension SoulverCore.TokenList : Swift.CustomDebugStringConvertible {
  final public var debugDescription: Swift.String {
    get
  }
}
extension SoulverCore.TokenList {
  final public subscript(index: Swift.Int) -> SoulverCore.Token {
    get
    set(newValue)
  }
  final public var count: Swift.Int {
    get
  }
  final public var isEmpty: Swift.Bool {
    get
  }
  final public func typePrecheck(_ type: SoulverCore.TokenType) -> Swift.Bool
  final public func typesPrecheck(_ types: SoulverCore.TokenTypeSet) -> Swift.Bool
  final public func allTypesHaveBeenPresentIn(_ types: SoulverCore.TokenTypeSet) -> Swift.Bool
  final public func onlyTypesHaveBeenPresentIn(_ types: SoulverCore.TokenTypeSet) -> Swift.Bool
  final public func anyTypesHaveBeenPresentIn(_ types: SoulverCore.TokenTypeSet) -> Swift.Bool
  final public func firstToken(ofType: SoulverCore.TokenType) -> SoulverCore.Token?
  final public func lastToken(ofType: SoulverCore.TokenType) -> SoulverCore.Token?
  final public func lastToken(ofTypes: SoulverCore.TokenTypeSet) -> SoulverCore.Token?
  final public func tokenBefore(_ token: SoulverCore.Token, mustBe type: SoulverCore.TokenType, ignoreWhitespace: Swift.Bool = true, ignoreTypes: SoulverCore.TokenTypeSet? = nil) -> SoulverCore.Token?
  final public func tokenAfter(_ token: SoulverCore.Token, mustBe type: SoulverCore.TokenType, ignoreWhitespace: Swift.Bool = true, ignoreTypes: SoulverCore.TokenTypeSet? = nil) -> SoulverCore.Token?
  final public func tokensOfType(_ tokenType: SoulverCore.TokenType) -> [SoulverCore.Token]
  final public func tokensOfTypes(_ tokenTypeSet: SoulverCore.TokenTypeSet) -> [SoulverCore.Token]
  final public func allTokensOfType(_ tokenType: SoulverCore.TokenType, excludingTokensWhereParentIsIn parentTokenTypes: SoulverCore.TokenTypeSet = TokenTypeSet(types: [])) -> [SoulverCore.Token]
  final public func allTokensOfTypes(_ tokenTypes: SoulverCore.TokenTypeSet, excludingTokensWhereParentIsIn parentTokenTypes: SoulverCore.TokenTypeSet = TokenTypeSet(types: [])) -> [SoulverCore.Token]
  final public func scanForTokenWithTypes(_ tokenTypes: SoulverCore.TokenTypeSet, ignoreParentsWithTypes parentTypes: SoulverCore.TokenTypeSet? = nil) -> Swift.Bool
  final public func enumerateSublists(reversed: Swift.Bool, includeSelf: Swift.Bool, enumerationBlock: (_ subList: SoulverCore.TokenList, _ parent: SoulverCore.Token?) -> Swift.Void)
  final public func findParentOf(childToken: SoulverCore.Token, highestLevelParent: Swift.Bool = false, inRange limitToRange: Swift.ClosedRange<Swift.Int>? = nil) -> SoulverCore.Token?
  final public func tokenFor(tokenIndex: SoulverCore.TokenIndex) -> SoulverCore.Token?
  final public func tokenIndexFor(token: SoulverCore.Token, topLevelOnly: Swift.Bool = false) -> SoulverCore.TokenIndex?
  final public func tokenFor(characterIndex: Swift.Int, ignoreWhitespace: Swift.Bool = true, endOfLineReturnsLastToken: Swift.Bool = false) -> SoulverCore.Token?
  public typealias TokenListEnumerationBlock = (SoulverCore.Token, SoulverCore.TokenList, SoulverCore.Token?) -> Swift.Void
  final public func enumerateAllTokensOfType(_ type: SoulverCore.TokenType, reversed: Swift.Bool = true, enumerationBlock: (SoulverCore.Token, SoulverCore.TokenList, SoulverCore.Token?) -> Swift.Void)
  final public func expressionByReplacingTokensOf(types: SoulverCore.TokenTypeSet, exceptWhereParentIsIn parentSkipTypes: SoulverCore.TokenTypeSet? = nil, replacementBlock: (SoulverCore.Token) -> Swift.String?) -> Swift.String
  final public func expressionAfter(_ token: SoulverCore.Token) -> Swift.String
  final public func expressionBefore(_ token: SoulverCore.Token) -> Swift.String
}
extension SoulverCore.TokenList : @unchecked Swift.Sendable {
}
public struct Resolution {
  public let width: Foundation.Decimal
  public let height: Foundation.Decimal
}
public struct GPSCoordinates : Swift.Equatable, Swift.Hashable {
  public var latitude: Swift.Double {
    get
  }
  public var longitude: Swift.Double {
    get
  }
  public static func == (a: SoulverCore.GPSCoordinates, b: SoulverCore.GPSCoordinates) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum TokenListForm : Swift.Equatable {
  case singleNumber(value: Foundation.Decimal)
  case singleUnitExpression(value: SoulverCore.UnitExpression)
  case singleDatestamp(value: SoulverCore.Datestamp)
  case conversion(fromUnit: SoulverCore.SCUnit, toUnit: SoulverCore.SCUnit, quantity: Foundation.Decimal)
  case dateSeeking(startDate: SoulverCore.Datestamp, timespan: SoulverCore.Timespan, direction: Foundation.Calendar.SearchDirection)
  case unitUntilDateSeeking(unit: SoulverCore.SCUnit, toDate: SoulverCore.Datestamp)
  case intervalBetweenDatesSeeking(startDate: SoulverCore.Datestamp, endDate: SoulverCore.Datestamp, unit: SoulverCore.SCUnit?)
  case timeAtPlaceSeeking(place: SoulverCore.Place)
  case timeDifferenceBetweenPlacesSeeking(firstPlace: SoulverCore.Place, secondPlace: SoulverCore.Place)
  case timeConversionToPlace(fromDate: SoulverCore.Datestamp, toPlace: SoulverCore.Place)
  case customFunction(function: SoulverCore.CustomFunction, parameters: [SoulverCore.EvaluationResult])
  case other
  public static func == (a: SoulverCore.TokenListForm, b: SoulverCore.TokenListForm) -> Swift.Bool
}
public struct Timestamp : Swift.Equatable {
  public let decimalValue: Foundation.Decimal
  public static func == (a: SoulverCore.Timestamp, b: SoulverCore.Timestamp) -> Swift.Bool
}
public struct iso8601 : Swift.Equatable {
  public let datestamp: SoulverCore.Datestamp
  public static func == (a: SoulverCore.iso8601, b: SoulverCore.iso8601) -> Swift.Bool
}
public struct EngineCustomization : @unchecked Swift.Sendable {
  public var locale: Foundation.Locale {
    get
  }
  public var calendar: Foundation.Calendar {
    get
  }
  public var timeZone: Foundation.TimeZone {
    get
  }
  public var customUnits: [SoulverCore.CustomUnit]
  public var currencyRateProvider: (any SoulverCore.CurrencyRateProvider)?
  public var weatherDataProvider: (any SoulverCore.WeatherDataProvider)?
  public var placeDataProvider: (any SoulverCore.PlaceDataProvider)?
  public enum CurrencySymbolSettings : Swift.Equatable, Swift.Hashable {
    case automatic
    case manualWith(symbols: [SoulverCore.UnitSymbolReplacement])
    public static func == (a: SoulverCore.EngineCustomization.CurrencySymbolSettings, b: SoulverCore.EngineCustomization.CurrencySymbolSettings) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var currencySymbolSettings: SoulverCore.EngineCustomization.CurrencySymbolSettings
  public var customPlaces: [SoulverCore.Place]
  public var customFunctions: [SoulverCore.CustomFunction]
  public var holidays: [SoulverCore.Holiday]
  public var unitSystem: SoulverCore.UnitMeasurementSystem
  public var baseFontSize: Foundation.Decimal
  public var featureFlags: SoulverCore.EngineFeatureFlags
  public init(locale: Foundation.Locale, calendar: Foundation.Calendar? = nil)
  public init(resourcesBundle: SoulverCore.ResourceBundle, locale: Foundation.Locale, calendar: Foundation.Calendar? = nil)
  public static func standardWith(locale: Foundation.Locale, calendar: Foundation.Calendar? = nil) -> SoulverCore.EngineCustomization
  public func convertTo(locale: Foundation.Locale) -> SoulverCore.EngineCustomization
}
extension SoulverCore.EngineCustomization : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension SoulverCore.EngineCustomization : Swift.Hashable, Swift.Equatable {
  public static func == (lhs: SoulverCore.EngineCustomization, rhs: SoulverCore.EngineCustomization) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct Datespan : Swift.Equatable {
  public let startDate: Foundation.Date
  public let endDate: Foundation.Date
  public var dateIntervalValue: Foundation.DateInterval {
    get
  }
  public static func == (a: SoulverCore.Datespan, b: SoulverCore.Datespan) -> Swift.Bool
}
public typealias PrototypeExpression = Swift.String
indirect public enum EvaluationResult {
  case rawString(Swift.String)
  case decimal(Foundation.Decimal)
  case percentage(SoulverCore.Percentage)
  case fraction(SoulverCore.Fraction)
  case scientificNotation(Foundation.Decimal)
  case binary(Swift.UInt)
  case octal(Swift.UInt)
  case hex(Swift.UInt)
  case multiplier(SoulverCore.Multiplier)
  case boolean(Swift.Bool)
  case unitExpression(SoulverCore.UnitExpression)
  case decimalRate(SoulverCore.DecimalRate)
  case unitRate(SoulverCore.UnitRate)
  case percentageRate(SoulverCore.PercentageRate)
  case unitRange(SoulverCore.UnitRange)
  case date(SoulverCore.Datestamp)
  case datespan(SoulverCore.Datespan)
  case iso8601(SoulverCore.iso8601)
  case timestamp(SoulverCore.Timestamp)
  case timespan(SoulverCore.Timespan)
  case laptime(SoulverCore.Laptime)
  case frametime(SoulverCore.Frametime)
  case gpsCoordinates(SoulverCore.GPSCoordinates)
  case degreesMinutesSeconds(SoulverCore.DegreesMinutesSeconds)
  case resolution(SoulverCore.Resolution)
  case salesTax(SoulverCore.SalesTax)
  case pitch(SoulverCore.Pitch)
  case unit(SoulverCore.SCUnit)
  case substance(SoulverCore.Substance)
  case place(SoulverCore.Place)
  case dynamicPlace(Swift.String)
  case customType(SoulverCore.CustomType)
  case statisticType(SoulverCore.StatisticType)
  case list(SoulverCore.List)
  case variable(SoulverCore.Variable)
  case addingContext(context: Swift.String, toResult: SoulverCore.EvaluationResult)
  case error(SoulverCore.EvaluationError)
  case customUnit(SoulverCore.CustomUnit)
  case pending
  case failed
  case none
  public var stringValue: Swift.String? {
    get
  }
  public var equivalentTokenType: SoulverCore.TokenType {
    get
  }
  public var decimalValue: Foundation.Decimal? {
    get
  }
  public var unitExpressionValue: SoulverCore.UnitExpression? {
    get
  }
  public var rateValue: SoulverCore.UnitRate? {
    get
  }
  public var booleanValue: Swift.Bool? {
    get
  }
  public var percentageValue: SoulverCore.Percentage? {
    get
  }
  public var unitRangeValue: SoulverCore.UnitRange? {
    get
  }
  public var datestampValue: SoulverCore.Datestamp? {
    get
  }
  public var datespanValue: SoulverCore.Datespan? {
    get
  }
  public var placeValue: SoulverCore.Place? {
    get
  }
  public var timespanValue: SoulverCore.Timespan? {
    get
  }
  public var unitValue: SoulverCore.SCUnit? {
    get
  }
  public var substanceValue: SoulverCore.Substance? {
    get
  }
  public var gpsCoordinatesValue: SoulverCore.GPSCoordinates? {
    get
  }
  public var dmsValue: SoulverCore.DegreesMinutesSeconds? {
    get
  }
  public var variableValue: SoulverCore.Variable? {
    get
  }
  public var errorValue: SoulverCore.EvaluationError? {
    get
  }
}
extension SoulverCore.EvaluationResult : Swift.Equatable {
  public static func == (lhs: SoulverCore.EvaluationResult, rhs: SoulverCore.EvaluationResult) -> Swift.Bool
}
extension SoulverCore.EvaluationResult : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension SoulverCore.EvaluationResult : @unchecked Swift.Sendable {
}
extension SoulverCore.UnitIdentifier {
  public var currencyCode: SoulverCore.CurrencyCode? {
    get
  }
}
public struct CustomUnit : Swift.Hashable, Swift.Equatable, Swift.Codable {
  public let name: Swift.String
  public let definition: Foundation.Decimal
  public let equivalentUnit: SoulverCore.UnitIdentifier
  public let legacyDefinition: Swift.String?
  public init(name: Swift.String, definition: Foundation.Decimal, equivalentUnit: SoulverCore.UnitIdentifier)
  public init(from decoder: any Swift.Decoder) throws
  public static func == (a: SoulverCore.CustomUnit, b: SoulverCore.CustomUnit) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public typealias UID = Swift.String
public struct LineReference : Swift.CustomStringConvertible {
  public let UID: SoulverCore.UID
  public init(UID: SoulverCore.UID)
  public var description: Swift.String {
    get
  }
}
extension SoulverCore.LineReference : Swift.Equatable, Swift.Codable, Swift.Hashable, Swift.Sendable {
  public static func == (a: SoulverCore.LineReference, b: SoulverCore.LineReference) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct Country {
  public let name: Swift.String
  public let capital: Swift.String
  public let code: Swift.String?
  public let capitalCityTimezoneID: Swift.String?
  public var timeZone: Foundation.TimeZone? {
    get
  }
}
extension SoulverCore.Country : Swift.Codable, Swift.Equatable, Swift.Hashable {
  public static func == (a: SoulverCore.Country, b: SoulverCore.Country) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct City {
  public let identifier: Swift.String
  public var name: Swift.String!
  public var country: Swift.String?
  public let countryCode: Swift.String
  public let longitude: Swift.String?
  public let latitude: Swift.String?
  public let timezone_id: Swift.String
  public var airportCodes: [Swift.String]!
  public var timeZone: Foundation.TimeZone? {
    get
  }
}
extension SoulverCore.City : Swift.Codable, Swift.Equatable, Swift.Hashable {
  public static func == (a: SoulverCore.City, b: SoulverCore.City) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct UnitExpression {
  public let value: Foundation.Decimal
  public let unit: SoulverCore.SCUnit
  public func convertedTo(unit identifier: SoulverCore.UnitIdentifier) -> SoulverCore.UnitExpression?
}
extension SoulverCore.UnitExpression {
  public static func with(unit: SoulverCore.UnitIdentifier, and value: Foundation.Decimal) -> SoulverCore.UnitExpression
}
extension SoulverCore.UnitExpression : Swift.Comparable {
  public static func == (lhs: SoulverCore.UnitExpression, rhs: SoulverCore.UnitExpression) -> Swift.Bool
  public static func < (lhs: SoulverCore.UnitExpression, rhs: SoulverCore.UnitExpression) -> Swift.Bool
}
extension SoulverCore.UnitExpression : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension SoulverCore.SCUnit {
  public var prefersZeroDP: Swift.Bool {
    get
  }
  public var prefersThreeDP: Swift.Bool {
    get
  }
  public var isCryptoCurrency: Swift.Bool {
    get
  }
}
public struct EngineFeatureFlags : Swift.Hashable, Swift.Equatable {
  public init()
  public var units: Swift.Bool
  public var calendarCalculations: Swift.Bool
  public var wordFunctions: Swift.Bool
  public var variableDeclarations: Swift.Bool
  public var disabledFunctions: Swift.Set<SoulverCore.FunctionIdentifier>?
  public var functionsRequireParentheses: Swift.Bool
  public var dynamicPlaceQueries: Swift.Bool
  public var historicalWeatherQueries: Swift.Bool
  public var historicalCurrencyQueries: Swift.Bool
  public var disabledConverters: Swift.Set<SoulverCore.ConverterIdentifier>?
  public var misplacedThousandsSeparatorBehavior: SoulverCore.MisplacedThousandsSeparatorBehavior
  public var timezoneCodeAutocorrectionBehavior: SoulverCore.TimezoneCodeCorrectionBehavior
  public var dateParsingOptions: SoulverCore.DateParsingOptions
  public var preserveAllParsedTokenTypes: Swift.Bool
  public var useDefaultRatesForUnhandledCurrencies: Swift.Bool
  public var inAmbiguityPreferSomethingToNothing: Swift.Bool
  public static func == (a: SoulverCore.EngineFeatureFlags, b: SoulverCore.EngineFeatureFlags) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension SoulverCore.EngineFeatureFlags {
  public var seeksFutureDate: Swift.Bool {
    get
    set
  }
  @available(*, deprecated, message: "Use `misplacedThousandsSeparatorBehavior = MisplacedThousandsSeparatorBehavior.allow` instead.")
  public var allowMisplacedThousandsSeparators: Swift.Bool {
    get
    set
  }
  @available(*, deprecated, message: "Use `timezoneCodeAutocorrectionBehavior = TimezoneCodeCorrectionBehavior.automatic` instead.")
  public var preferActiveTimeZoneAbbreviations: Swift.Bool {
    get
    set
  }
  @available(*, deprecated, message: "Use commentingOptions.hashTags on LineCollection")
  public var hashTags: Swift.Bool {
    get
    set
  }
  @available(*, deprecated, message: "Use commentingOptions.quotationMarkComments on LineCollection")
  public var quotationMarkComments: Swift.Bool {
    get
    set
  }
  @available(*, deprecated, message: "Use commentingOptions.bracketComments on LineCollection")
  public var bracketComments: Swift.Bool {
    get
    set
  }
  @available(*, deprecated, message: "Use commentingOptions.labelComments on LineCollection")
  public var labelComments: Swift.Bool {
    get
    set
  }
  @available(*, deprecated, message: "Use commentingOptions.trailingComments on LineCollection")
  public var trailingComments: Swift.Bool {
    get
    set
  }
}
extension SoulverCore.EngineFeatureFlags {
  public mutating func _limitToLegacyFeatureSet()
  public mutating func _limitToShippingFeatureSet()
}
public typealias ScalarSymbol = Swift.String
public enum ScalarSystem : Swift.String, Swift.Codable, Swift.Sendable {
  case standard
  case russian
  case chinese
  case currencyUppercase
  case currencyLowercase
  case currencyBritish
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum MisplacedThousandsSeparatorBehavior {
  case allow
  case disallow
  case interpretAsDecimalPoint
  public static func == (a: SoulverCore.MisplacedThousandsSeparatorBehavior, b: SoulverCore.MisplacedThousandsSeparatorBehavior) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct DecimalRate : Swift.Equatable {
  public static func == (a: SoulverCore.DecimalRate, b: SoulverCore.DecimalRate) -> Swift.Bool
}
public struct Percentage : Swift.Equatable {
  public let decimalValue: Foundation.Decimal
  public init(value: Foundation.Decimal)
  public static func == (a: SoulverCore.Percentage, b: SoulverCore.Percentage) -> Swift.Bool
}
public enum FunctionIdentifier : Swift.String, Swift.CaseIterable, Swift.RawRepresentable, Swift.Sendable {
  case halfOf
  case lesserOf
  case greaterOf
  case midpoint
  case proportionsFindNumerator
  case proportionsFindDenominator
  case remainder
  case dividedBy
  case isPrime
  case clamp
  case multipliedBy
  case toThePowerOf
  case makeRandomNumber
  case gcd
  case lcm
  case squareRoot
  case cubedRoot
  case nthRoot
  case nthLog
  case nthLogReversed
  case roundUpXToNearestY
  case roundDownXToNearestY
  case roundXToNearestY
  case roundXDown
  case roundXUp
  case roundXToDP
  case combination
  case permutation
  case reversedCombination
  case reversedPermutation
  case percentOf
  case percentOff
  case percentOn
  case isPercentOfWhat
  case isPercentOffWhat
  case isPercentOnWhat
  case isPercentOfWhatClassic
  case isPercentOffWhatClassic
  case isPercentOnWhatClassic
  case isWhatPercentOf
  case isWhatPercentOff
  case isWhatPercentOn
  case isWhatPercentWith
  case isWhatPercentChangeAfterDelta
  case percentageRuleOfThree
  case reversedPercentOf
  case reversedPercentOff
  case reversedPercentOn
  case isWhatMultiplierOf
  case isWhatMultiplierOn
  case isWhatMultiplierOff
  case salesTaxIn
  case salesTaxOff
  case historicalCurrencyConversion
  case exchangeRateForCurrencyConversion
  case exponentialGrowth
  case exponentialDecay
  case timeRequiredForExponentialChange
  case growthOverExponentialChange
  case timeRequiredForLinearChange
  case xToYIsWhatPercentage
  case xToYIsWhatMultiplier
  case xOfY
  case xOnY
  case xOffY
  case timeInTimezone
  case dateInTimezone
  case differenceBetweenTimezones
  case generateTimestamp
  case calendarUnitBetweenDates
  case inclusiveCalendarUnitBetweenDates
  case intervalBetweenDates
  case inclusiveIntervalBetweenDates
  case calendarUnitToDate
  case calendarUnitSinceDate
  case calendarUnitInDate
  case calendarUnitLeftInDate
  case calendarUnitToDatespan
  case calendarUnitInDatespan
  case calendarUnitExpressionAgo
  case timeAfterCalendarUnit
  case calendarUnitExpressionBeforeDate
  case calendarUnitExpressionAfterDate
  case halfwayBetweenDates
  case lunarDay
  case dayOfMonthOnDate
  case dayOfMonth
  case dayOfYearOnDate
  case dayOfYear
  case weekOfMonthOnDate
  case weekOfMonth
  case weekOfYearOnDate
  case weekOfYear
  case weekdayAfterTimespan
  case dayOfWeekOnDate
  case formFrametime
  case framesToFrametime
  case intervalBetweenTimestamps
  case intervalBetweenLaptimes
  case framesBetweenFrametimes
  case intervalBetweenFrametimes
  case unitConversion
  case unitInUnitExpression
  case calendarUnitInTimespan
  case calendarUnitPercentage
  case rateUnitChange
  case rateForADuration
  case substanceWeightToVolumeConversion
  case densityOfSubstance
  case speedForTime
  case timeSavedAtMultiplier
  case timeAtMultiplier
  case powerAtRotation
  case presentValue
  case returnOnInvestmentAfter
  case returnOnInvestment
  case investmentRequiredForReturn
  case dailyInterestOnLoanRepayment
  case monthlyInterestOnLoanRepayment
  case annualInterestOnLoanRepayment
  case totalInterestOnLoanRepayment
  case dailyLoanRepayment
  case monthlyLoanRepayment
  case annualLoanRepayment
  case totalLoanRepayment
  case compoundInterestSansPrincipal
  case compoundInterestSansPrincipalCompoundingMonthly
  case compoundInterestSansPrincipalCompoundingQuarterly
  case compoundInterestCompoundingQuarterly
  case compoundInterestCompoundingMonthly
  case compoundInterest
  case dollarWorthAdjustedForInflation
  case predictedDollarWorthGivenInflation
  case dollarWorthFromTodayAdjustedForInflation
  case dollarWorthToTodayAdjustedForInflation
  case gpsCoordinatesOfPlace
  case longitudeOfPlace
  case latitudeOfPlace
  case distanceBetweenPlaces
  case pixelsInLengthAtPPI
  case screenDensity
  case tyreSpeed
  case lowTemperature
  case highTemperature
  case precipitationChance
  case rainfallAmount
  case snowfallAmount
  case apparentTemperature
  case currentTemperature
  case weatherConditions
  case humidity
  case cloudCover
  case visibility
  case windDirection
  case windSpeed
  case dewPoint
  case uvIndex
  case pressureDirection
  case pressure
  case sunrise
  case sunset
  case moonrise
  case moonset
  case moonPhase
  case statisticOfList
  case statisticOfTag
  case countOfLiteral
  case extractLiteralPrefix
  case extractLiteralSuffix
  case parseLiteral
  case scrubNumberWithSpecifiedRange
  case declareGenericUnit
  case unknown
  public var returnType: SoulverCore.TokenType? {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias AllCases = [SoulverCore.FunctionIdentifier]
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [SoulverCore.FunctionIdentifier] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
extension SoulverCore.FunctionIdentifier : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
public typealias PrivateUnicodeSymbol = Swift.String
@_hasMissingDesignatedInitializers public class SingleCharacterUIDGenerator {
  public class func isUID(symbol: SoulverCore.PrivateUnicodeSymbol) -> Swift.Bool
  public class func parameterIndexFor(UID: SoulverCore.PrivateUnicodeSymbol) -> Swift.Int?
  @objc deinit
}
public struct AlternativeResult {
  public let calculationResult: SoulverCore.CalculationResult
  public let format: SoulverCore.AlternativeResult.Format
  public enum Format {
    case decimal
    case binary
    case hexadecimal
    case octal
    case fraction
    case scientificNotation
    case timespan
    case laptime
    case humanReadableDate
    case iso8601
    case timestamp
    public var title: Swift.String {
      get
    }
    public static func == (a: SoulverCore.AlternativeResult.Format, b: SoulverCore.AlternativeResult.Format) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
public class AlternativeResultGenerator {
  public init(customization: SoulverCore.EngineCustomization, formattingPreferences: SoulverCore.FormattingPreferences? = nil)
  public func alternativeResultsFor(result: SoulverCore.CalculationResult) -> [SoulverCore.AlternativeResult]
  @objc deinit
}
public struct FormattingPreferences : Swift.Codable, Swift.Equatable, Swift.Hashable, Swift.Sendable {
  public static let maximumDp: Swift.Int
  public var dp: Swift.Int
  public var thousandsSeparatorDisabled: Swift.Bool
  public var currencyFormattingPreferences: SoulverCore.CurrencyFormattingPreferences
  public var notationPreferences: SoulverCore.NotationPreferences
  public var referencesTakeFormattedValue: Swift.Bool
  public var resultConversionBehavior: SoulverCore.ResultConversionBehavior
  public init()
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public static func == (a: SoulverCore.FormattingPreferences, b: SoulverCore.FormattingPreferences) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension SoulverCore.FormattingPreferences {
  public static var unformatted: SoulverCore.FormattingPreferences {
    get
  }
}
public struct CurrencyFormattingPreferences : Swift.Equatable, Swift.Hashable, Swift.Codable, Swift.Sendable {
  public var useCurrencySymbols: Swift.Bool
  public var roundResults: Swift.Bool
  public var showTrailingZeros: Swift.Bool
  public var preferredScalarSystem: SoulverCore.ScalarSystem?
  public static let standard: SoulverCore.CurrencyFormattingPreferences
  public static let disabled: SoulverCore.CurrencyFormattingPreferences
  public static func == (a: SoulverCore.CurrencyFormattingPreferences, b: SoulverCore.CurrencyFormattingPreferences) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct NotationPreferences : Swift.Equatable, Swift.Hashable, Swift.Sendable {
  public enum NotationStyle : Swift.Sendable {
    case auto
    case on
    case off
    public static func == (a: SoulverCore.NotationPreferences.NotationStyle, b: SoulverCore.NotationPreferences.NotationStyle) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var notationStyle: SoulverCore.NotationPreferences.NotationStyle
  public var upperNotationThreshold: SoulverCore.SIThreshold
  public init(notationStyle: SoulverCore.NotationPreferences.NotationStyle, upperNotationThreshold: SoulverCore.SIThreshold = .trillion)
  public static var off: SoulverCore.NotationPreferences {
    get
  }
  public static func == (a: SoulverCore.NotationPreferences, b: SoulverCore.NotationPreferences) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum ResultConversionRule : Swift.Equatable, Swift.Hashable, Swift.Sendable {
  case tokenOf(type: SoulverCore.TokenType, convertToType: SoulverCore.TokenType)
  case tokenWith(subType: SoulverCore.TokenSubType, convertToType: SoulverCore.TokenType)
  case unitExpressionOf(unitType: SoulverCore.UnitType, convertToUnit: SoulverCore.UnitIdentifier)
  case unitExpressionWith(identifier: SoulverCore.UnitIdentifier, convertToUnit: SoulverCore.UnitIdentifier)
  case convertToTimespanUnitExpressionWith(identifier: SoulverCore.UnitIdentifier)
  case convertToFeetAndInchesUnitExpressionWith(identifier: SoulverCore.UnitIdentifier)
  case timeWithTimezone(convertToTimezone: Foundation.TimeZone)
  public static func == (a: SoulverCore.ResultConversionRule, b: SoulverCore.ResultConversionRule) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum ResultConversionBehavior : Swift.Equatable, Swift.Hashable, Swift.Sendable {
  case none
  case automatic
  case customRules([SoulverCore.ResultConversionRule])
  public static func == (a: SoulverCore.ResultConversionBehavior, b: SoulverCore.ResultConversionBehavior) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension SoulverCore.FormattingPreferences {
  public var currencyFormattingDisabled: Swift.Bool {
    get
    set
  }
  public var fractionizeWherePossible: Swift.Bool {
    get
    set
  }
}
public class ResultOperations {
  public init(customization: SoulverCore.EngineCustomization, formattingPreferences: SoulverCore.FormattingPreferences?)
  public func add(leftSide: SoulverCore.CalculationResult, rightSide: SoulverCore.CalculationResult) -> SoulverCore.CalculationResult?
  public func subtract(rightSide: SoulverCore.CalculationResult, from leftSide: SoulverCore.CalculationResult) -> SoulverCore.CalculationResult?
  public func negate(calculationResult: SoulverCore.CalculationResult) -> SoulverCore.CalculationResult?
  @objc deinit
}
public class ResultCollection {
  final public let results: [SoulverCore.CalculationResult]
  final public let customization: SoulverCore.EngineCustomization
  final public let formattingPreferences: SoulverCore.FormattingPreferences?
  public init(results: [SoulverCore.CalculationResult], customization: SoulverCore.EngineCustomization, formattingPreferences: SoulverCore.FormattingPreferences? = nil)
  public var sum: SoulverCore.CalculationResult? {
    get
  }
  public var average: SoulverCore.CalculationResult? {
    get
  }
  public var median: SoulverCore.CalculationResult? {
    get
  }
  public var max: SoulverCore.CalculationResult? {
    get
  }
  public var min: SoulverCore.CalculationResult? {
    get
  }
  public var count: SoulverCore.CalculationResult? {
    get
  }
  public var allResultsAreEmpty: Swift.Bool {
    get
  }
  public var allResultsAreNonEmpty: Swift.Bool {
    get
  }
  @objc deinit
}
public class ResultPercentageCalculator {
  public init(customization: SoulverCore.EngineCustomization)
  public func percentageOf(calculationResult: SoulverCore.CalculationResult, whole: SoulverCore.CalculationResult, percentageFormattingPreferences: SoulverCore.FormattingPreferences? = nil) -> SoulverCore.CalculationResult?
  public func percentageChange(start: SoulverCore.CalculationResult, end: SoulverCore.CalculationResult, percentageFormattingPreferences: SoulverCore.FormattingPreferences? = nil) -> SoulverCore.CalculationResult?
  @objc deinit
}
public protocol DynamicVariable {
  var identifier: SoulverCore.LineReference { get }
  var evaluatedResult: SoulverCore.EvaluationResult? { get }
}
public struct ResourceBundle : Swift.Sendable, Swift.Equatable {
  public init?(url: Foundation.URL)
  public struct ResourcesBundleVersion : Swift.Codable, Swift.Sendable, Swift.Equatable {
    public let version: Swift.String
    public let build: Swift.String
    public static func == (a: SoulverCore.ResourceBundle.ResourcesBundleVersion, b: SoulverCore.ResourceBundle.ResourcesBundleVersion) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public enum ResourcesBundleLocation : Swift.Sendable, Swift.Equatable {
    case mainBundle
    case externalBundle(Foundation.URL)
    public static func == (a: SoulverCore.ResourceBundle.ResourcesBundleLocation, b: SoulverCore.ResourceBundle.ResourcesBundleLocation) -> Swift.Bool
  }
  public static func == (a: SoulverCore.ResourceBundle, b: SoulverCore.ResourceBundle) -> Swift.Bool
}
public typealias VariableName = Swift.String
public typealias VariableValue = Swift.String
public struct Variable : Swift.Codable, Swift.Sendable {
  public enum VariableType : Swift.String, Swift.RawRepresentable, Swift.Codable, Swift.Sendable {
    case undefined
    case local
    case global
    case lineReference
    case relativeLineReference
    case parameter
    case tag
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public let name: SoulverCore.VariableName
  public let value: SoulverCore.VariableValue?
  public init(name: SoulverCore.VariableName, value: SoulverCore.VariableValue? = nil, type: SoulverCore.Variable.VariableType = .undefined)
  public var definition: SoulverCore.EvaluationResult?
  public var type: SoulverCore.Variable.VariableType
  public var isPhrase: Swift.Bool?
  public var declaringLineIndex: SoulverCore.LineIndex?
  public var relatedLineIndexes: Foundation.IndexSet?
  public var representedResults: [SoulverCore.EvaluationResult]?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension SoulverCore.Variable : Swift.Hashable, Swift.Equatable {
  public static func == (lhs: SoulverCore.Variable, rhs: SoulverCore.Variable) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum TokenType : Swift.CaseIterable, Swift.Sendable {
  case number
  case `operator`
  case percentageSymbol
  case converterSymbol
  case unit
  case bracket
  case whitespace
  case variable
  case dynamicVariable
  case equals
  case percentageWord
  case timespanWord
  case conditionalKeyword
  case conjunctionWord
  case prepositionWord
  case grammerArticleWord
  case grammarPossessiveWord
  case functionName
  case javascriptFunctionName
  case timezone
  case degreesMinutesSeconds
  case gpsCoordinates
  case substance
  case comma
  case dot
  case quotationMark
  case colon
  case semicolon
  case hash
  case questionMark
  case label
  case fraction
  case converter
  case unixTimestamp
  case datestamp
  case iso8601
  case timespan
  case laptime
  case frametime
  case datespan
  case dateWord
  case specialDay
  case pitch
  case dateQualifier
  case ordinalSuffix
  case relativePlaceWord
  case numberWord
  case constantWord
  case statisticType
  case unitExpression
  case compoundUnitExpression
  case unitRange
  case conditionalExpression
  case percentage
  case salesTax
  case multiplier
  case resolution
  case list
  case boolean
  case rate
  case functionExpression
  case wordFunction
  case variableDeclaration
  case unitDeclaration
  case conditionalVariableDeclaration
  case declaredVariable
  case declaredUnit
  case variableAssignmentOperator
  case subexpression
  case wordComment
  case hashtag
  case bracketComment
  case trailingComment
  case legacyQuotationComment
  case labelExpression
  case url
  case customType
  case error
  case pending
  case failed
  case remoteQuery
  case scalar
  case unidentified
  case customInternal
  case customUnit
  case dateComponents
  case literal
  case anyWord
  case numberCluster
  case dynamicPlace
  public static func == (a: SoulverCore.TokenType, b: SoulverCore.TokenType) -> Swift.Bool
  public typealias AllCases = [SoulverCore.TokenType]
  nonisolated public static var allCases: [SoulverCore.TokenType] {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum TokenSubType : Swift.Sendable {
  case decimalNumber
  case binaryNumber
  case octalNumber
  case hexadecimalNumber
  case thousandScalar
  case millionScalar
  case billionScalar
  case trillionScalar
  case constantWordPi
  case constantWordTau
  case constantWordPhi
  case additionOperator
  case subtractionOperator
  case multiplicationOperator
  case divisionOperator
  case reverseDivisionOperator
  case reverseSubtractionOperator
  case powerOperator
  case modOperator
  case rateFormingDivisionOperator
  case lesserOf
  case greaterOf
  case greaterThan
  case greaterThanOrEqualTo
  case lessThan
  case lessThanOrEqualTo
  case equalTo
  case notEqualTo
  case logicalAndOperator
  case logicalOrOperator
  case logicalNotOperator
  case bitwiseAndOperator
  case bitwiseOrOperator
  case bitwiseXorOperator
  case bitwiseNotOperator
  case bitwiseLeftShiftOperator
  case bitwiseRightShiftOperator
  case squareRootSymbol
  case `false`
  case `true`
  case openBracket
  case closeBracket
  case converterSymbolTo
  case converterSymbolAs
  case converterSymbolIn
  case decimalRate
  case unitRate
  case percentageRate
  case clockstamp
  case dateWordTime
  case dateWordToday
  case dateWordNow
  case dateWordTomorrow
  case dateWordYesterday
  case dateWordDayOfWeek
  case dateWordMonthOfYear
  case dateWordQuarterOfYear
  case dateWordAm
  case dateWordPm
  case dateWordMidday
  case dateWordMidnight
  case dateWordSummer
  case dateWordAutumn
  case dateWordWinter
  case dateWordSpring
  case dateQualifierNext
  case dateQualifierThis
  case dateQualifierPrevious
  case relativePlaceWordHere
  case statisticWordTotal
  case statisticWordAverage
  case statisticWordCount
  case statisticWordMedian
  case statisticWordLesser
  case statisticWordGreater
  case statisticWordLCM
  case statisticWordGCD
  case statisticWordStandardDeviation
  case statisticWordReduction
  case prepositionWordOf
  case prepositionWordWith
  case prepositionWordBetween
  case prepositionWordAt
  case prepositionWordFor
  case prepositionWordFrom
  case prepositionWordSince
  case prepositionWordUntil
  case prepositionWordAfter
  case prepositionWordBefore
  case prepositionWordEarlier
  case prepositionWordLater
  case prepositionWordUpTo
  case definiteGrammarArticleWord
  case indefiniteGrammarArticleWord
  case grammarPossessiveWordOf
  case conjunctionWordAnd
  case conjunctionWordOr
  case builtInWordFunction
  case customWordFunction
  case regularVariableAssignment
  case additiveVariableAssignment
  case subtractiveVariableAssignment
  case multiplicativeVariableAssignment
  case diviziveVariableAssignment
  case conditionalKeywordIf
  case conditionalKeywordThen
  case conditionalKeywordElse
  case conditionalKeywordUnless
  case slashTrailingComment
  case hashTrailingComment
  case numberHeadCluster
  case numberMiddleCluster
  case numberTailCluster
  case unitMismatchError
  case infinityError
  case divideByZeroError
  case imaginaryNumberError
  case unsupportedExponentOperationError
  case unsupportedUnitMultiplicationError
  case unsupportedRateError
  case badDivisionError
  case impreciseResultError
  case silentError
  case unknownError
  case notSpecified
  public static func == (a: SoulverCore.TokenSubType, b: SoulverCore.TokenSubType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct SalesTax : Swift.Equatable {
  public init(decimalValue: Foundation.Decimal)
  public let decimalValue: Foundation.Decimal
  public static func == (a: SoulverCore.SalesTax, b: SoulverCore.SalesTax) -> Swift.Bool
}
extension Swift.String {
  public var isSingleWord: Swift.Bool {
    get
  }
  public var isPhrase: Swift.Bool {
    get
  }
}
public struct TokenListMetadata {
  public let form: SoulverCore.TokenListForm
  public let semantics: SoulverCore.TokenListSemantics
}
extension SoulverCore.TokenList {
  final public var metadata: SoulverCore.TokenListMetadata {
    get
  }
}
extension SoulverCore.Calculator {
  @available(*, deprecated, message: "Use ``String.dateValue`` or ``ObjectParser`` instead. This function will be removed in a future release.")
  final public func dateFor(_ expression: Swift.String, with variableList: SoulverCore.VariableList? = nil) -> (date: Foundation.Date, result: SoulverCore.CalculationResult)?
  @available(*, deprecated, message: "Use ``String/dateIntervalValue`` or ``ObjectParser`` instead. This function will be removed in a future release.")
  final public func dateIntervalFor(_ expression: Swift.String, with variableList: SoulverCore.VariableList? = nil) -> (dateInterval: Foundation.DateInterval, result: SoulverCore.CalculationResult)?
  @available(*, deprecated, message: "Use ``ObjectParser`` to parse data types from strings instead. This function will be removed in a future release.")
  final public class func functionParametersIn(_ expression: Swift.String, matching prototypeExpressions: [SoulverCore.PrototypeExpression], customization: SoulverCore.EngineCustomization = .standard) -> [SoulverCore.EvaluationResult]?
}
public struct SemanticToken {
  public let type: SoulverCore.SemanticToken.PartOfExpression
  public let range: Swift.Range<Swift.String.Index>
  public let token: SoulverCore.Token
  public enum PartOfExpression : Swift.CaseIterable {
    case number
    case `operator`
    case unit
    case boolean
    case functionName
    case parenthesis
    case converterWord
    case formSpecifier
    case country
    case city
    case airport
    case timezone
    case substance
    case url
    case variable
    case conditionalKeyword
    case heading
    case comment
    case headingIndicator
    case label
    case tag
    case tagIndicator
    case phraseFunction
    case date
    case other
    public static func == (a: SoulverCore.SemanticToken.PartOfExpression, b: SoulverCore.SemanticToken.PartOfExpression) -> Swift.Bool
    public typealias AllCases = [SoulverCore.SemanticToken.PartOfExpression]
    nonisolated public static var allCases: [SoulverCore.SemanticToken.PartOfExpression] {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
public struct Laptime : Swift.Equatable {
  public static func == (a: SoulverCore.Laptime, b: SoulverCore.Laptime) -> Swift.Bool
}
public struct Datestamp {
  public enum DatestampType : Swift.Sendable {
    case clockTime
    case utcTime
    case nakedDayOfMonth
    case nakedMonth
    case nakedYear
    case dayAndMonth
    case monthAndYear
    case dayMonthYear
    case dayMonthYearWithClockTimeDownToMinutes
    case dayMonthYearWithClockTimeDownToSeconds
    case dayMonthYearWithClockTimeDownToSubSeconds
    case dayMonthYearAndWeekday
    case weekDay
    case weekdayWithClockTime
    case relativeWeekday
    case now
    case today
    case tomorrow
    case yesterday
    case nextWeek
    case nextMonth
    case nextYear
    case lastWeek
    case lastYear
    case lastMonth
    case thisWeek
    case thisYear
    case thisMonth
    case quarter
    case unixTimestamp
    case iso8601
    case specialDay
    case nowInTimezone
    case unspecified
    public static func == (a: SoulverCore.Datestamp.DatestampType, b: SoulverCore.Datestamp.DatestampType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let date: Foundation.Date
  public var type: SoulverCore.Datestamp.DatestampType
  public let timezone: Foundation.TimeZone?
}
extension SoulverCore.Datestamp : Swift.Equatable {
  public static func == (lhs: SoulverCore.Datestamp, rhs: SoulverCore.Datestamp) -> Swift.Bool
}
extension SoulverCore.Datestamp {
  public var hasExplicitTimeZone: Swift.Bool {
    get
  }
  public static func datestampWith(date: Foundation.Date, ofType type: SoulverCore.Datestamp.DatestampType, inTimezone timezone: Foundation.TimeZone?) -> SoulverCore.Datestamp
}
extension SoulverCore.Datestamp.DatestampType {
  public var hasYearComponent: Swift.Bool {
    get
  }
  public var hasMonthComponent: Swift.Bool {
    get
  }
  public var hasDayComponent: Swift.Bool {
    get
  }
  public var hasTimeComponent: Swift.Bool {
    get
  }
  public var calendarComponentsRepresented: Swift.Set<Foundation.Calendar.Component> {
    get
  }
  public var largestUnit: SoulverCore.UnitIdentifier {
    get
  }
  public static let relativeTimeTypes: Swift.Set<SoulverCore.Datestamp.DatestampType>
  public var isRelative: Swift.Bool {
    get
  }
}
public struct UnitSymbolReplacement : Swift.Equatable, Swift.Hashable, Swift.Codable {
  public enum UnitSymbolReplacementPosition : Swift.String, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable {
    case before
    case beforeWithSpace
    case after
    case afterWithSpace
    public var description: Swift.String {
      get
    }
    public init?(rawValue: Swift.String)
    public typealias AllCases = [SoulverCore.UnitSymbolReplacement.UnitSymbolReplacementPosition]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [SoulverCore.UnitSymbolReplacement.UnitSymbolReplacementPosition] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  public let originalSymbol: Swift.String
  public let replacementSymbol: Swift.String
  public let position: SoulverCore.UnitSymbolReplacement.UnitSymbolReplacementPosition
  public init(original: Swift.String, replacement: Swift.String, position: SoulverCore.UnitSymbolReplacement.UnitSymbolReplacementPosition = .before)
  public static func standardCustomSymbolsFor(locale: Foundation.Locale) -> [SoulverCore.UnitSymbolReplacement]
  public static func == (a: SoulverCore.UnitSymbolReplacement, b: SoulverCore.UnitSymbolReplacement) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct List {
  public let members: [SoulverCore.EvaluationResult]
}
extension Swift.Collection where Self.Element == Swift.String {
  public func find<T>(_ find: SoulverCore.DataPoint<T>, locale: Foundation.Locale = .current) -> [T.DataType] where T : SoulverCore.DataFromTokenParser
  public func find<each T>(_ entities: repeat SoulverCore.DataPoint<each T>, locale: Foundation.Locale = .current) -> [(repeat (each T).DataType)] where repeat each T : SoulverCore.DataFromTokenParser
}
extension Swift.Collection where Self.Element == Swift.String {
  public func replacingAll<T>(_ entity: SoulverCore.DataPoint<T>, locale: Foundation.Locale = .current, replacement: (T.DataType) -> Swift.String?) -> [Swift.String] where T : SoulverCore.DataFromTokenParser
  public func replacingFirst<T>(_ entity: SoulverCore.DataPoint<T>, locale: Foundation.Locale = .current, replacement: (T.DataType) -> Swift.String?) -> [Swift.String] where T : SoulverCore.DataFromTokenParser
}
extension Foundation.Date : SoulverCore.ParsableObject {
  public init(from parser: SoulverCore.ObjectParser) throws
}
extension Foundation.DateInterval : SoulverCore.ParsableObject {
  public init(from parser: SoulverCore.ObjectParser) throws
}
extension Swift.String {
  public func parseObject<T>() throws -> T where T : SoulverCore.ParsableObject
  public var dateValue: Foundation.Date? {
    get
  }
  public var dateIntervalValue: Foundation.DateInterval? {
    get
  }
}
extension Swift.String {
  public func find<T>(_ entity: SoulverCore.DataPoint<T>, locale: Foundation.Locale = .current) -> T.DataType? where T : SoulverCore.DataFromTokenParser
  public func find<each T>(_ entities: repeat SoulverCore.DataPoint<each T>, locale: Foundation.Locale = .current) -> (repeat (each T).DataType)? where repeat each T : SoulverCore.DataFromTokenParser
  public func replacingAll<T>(_ entity: SoulverCore.DataPoint<T>, locale: Foundation.Locale = .current, replacement: (T.DataType) -> Swift.String?) -> Swift.String where T : SoulverCore.DataFromTokenParser
  public func replacingFirst<T>(_ entity: SoulverCore.DataPoint<T>, locale: Foundation.Locale = .current, replacement: (T.DataType) -> Swift.String?) -> Swift.String where T : SoulverCore.DataFromTokenParser
}
public protocol DataFromTokenParser {
  associatedtype DataType
  func parseDataFrom(token: SoulverCore.Token) -> Self.DataType?
}
public struct DataPoint<T> where T : SoulverCore.DataFromTokenParser {
  public init(parser: T)
}
extension SoulverCore.DataPoint : _StringProcessing.CustomConsumingRegexComponent {
  public typealias RegexOutput = T.DataType
  public func consuming(_ input: Swift.String, startingAt index: Swift.String.Index, in bounds: Swift.Range<Swift.String.Index>) throws -> (upperBound: Swift.String.Index, output: T.DataType)?
}
extension SoulverCore.DataPoint {
  public static var number: SoulverCore.DataPoint<SoulverCore.NumberFromTokenParser> {
    get
  }
  public static var digits: SoulverCore.DataPoint<SoulverCore.DigitsFromTokenParser> {
    get
  }
  public static var binaryNumber: SoulverCore.DataPoint<SoulverCore.BinaryNumberFromTokenParser> {
    get
  }
  public static var octalNumber: SoulverCore.DataPoint<SoulverCore.OctalNumberFromTokenParser> {
    get
  }
  public static var hexNumber: SoulverCore.DataPoint<SoulverCore.HexNumberFromTokenParser> {
    get
  }
  public static var date: SoulverCore.DataPoint<SoulverCore.DateFromTokenParser> {
    get
  }
  public static var datestamp: SoulverCore.DataPoint<SoulverCore.DatestampFromTokenParser> {
    get
  }
  public static var iso8601: SoulverCore.DataPoint<SoulverCore.iso8601FromTokenParser> {
    get
  }
  public static var unixTimestamp: SoulverCore.DataPoint<SoulverCore.UnixTimestampFromTokenParser> {
    get
  }
  public static var percentage: SoulverCore.DataPoint<SoulverCore.PercentageFromTokenParser> {
    get
  }
  public static var boolean: SoulverCore.DataPoint<SoulverCore.BooleanFromTokenParser> {
    get
  }
  public static var place: SoulverCore.DataPoint<SoulverCore.PlaceFromTokenParser> {
    get
  }
  public static var city: SoulverCore.DataPoint<SoulverCore.CityFromTokenParser> {
    get
  }
  public static var country: SoulverCore.DataPoint<SoulverCore.CountryFromTokenParser> {
    get
  }
  public static var airport: SoulverCore.DataPoint<SoulverCore.AirportFromTokenParser> {
    get
  }
  public static var timeZone: SoulverCore.DataPoint<SoulverCore.TimeZoneFromTokenParser> {
    get
  }
  public static var currencyCode: SoulverCore.DataPoint<SoulverCore.CurrencyCodeFromTokenParser> {
    get
  }
  public static var currency: SoulverCore.DataPoint<SoulverCore.UnitOfTypeFromTokenParser> {
    get
  }
  public static var time: SoulverCore.DataPoint<SoulverCore.UnitOfTypeFromTokenParser> {
    get
  }
  public static var distance: SoulverCore.DataPoint<SoulverCore.UnitOfTypeFromTokenParser> {
    get
  }
  public static var temperature: SoulverCore.DataPoint<SoulverCore.UnitOfTypeFromTokenParser> {
    get
  }
  public static var weight: SoulverCore.DataPoint<SoulverCore.UnitOfTypeFromTokenParser> {
    get
  }
  public static var area: SoulverCore.DataPoint<SoulverCore.UnitOfTypeFromTokenParser> {
    get
  }
  public static var speed: SoulverCore.DataPoint<SoulverCore.UnitOfTypeFromTokenParser> {
    get
  }
  public static var volume: SoulverCore.DataPoint<SoulverCore.UnitOfTypeFromTokenParser> {
    get
  }
  public static var fileSize: SoulverCore.DataPoint<SoulverCore.UnitOfTypeFromTokenParser> {
    get
  }
  public static var fileTransferSpeed: SoulverCore.DataPoint<SoulverCore.UnitOfTypeFromTokenParser> {
    get
  }
  public static var fuelEconomy: SoulverCore.DataPoint<SoulverCore.UnitOfTypeFromTokenParser> {
    get
  }
  public static var fuelConsumption: SoulverCore.DataPoint<SoulverCore.UnitOfTypeFromTokenParser> {
    get
  }
  public static var pressure: SoulverCore.DataPoint<SoulverCore.UnitOfTypeFromTokenParser> {
    get
  }
  public static var frequency: SoulverCore.DataPoint<SoulverCore.UnitOfTypeFromTokenParser> {
    get
  }
  public static var power: SoulverCore.DataPoint<SoulverCore.UnitOfTypeFromTokenParser> {
    get
  }
  public static var angle: SoulverCore.DataPoint<SoulverCore.UnitOfTypeFromTokenParser> {
    get
  }
  public static func unitOf(_ type: SoulverCore.UnitType) -> SoulverCore.DataPoint<SoulverCore.UnitOfTypeFromTokenParser>
  public static var timespan: SoulverCore.DataPoint<SoulverCore.TimespanFromTokenParser> {
    get
  }
  public static var laptime: SoulverCore.DataPoint<SoulverCore.LaptimeFromTokenParser> {
    get
  }
  public static var timecode: SoulverCore.DataPoint<SoulverCore.TimecodeFromTokenParser> {
    get
  }
  public static var url: SoulverCore.DataPoint<SoulverCore.URLFromTokenParser> {
    get
  }
  public static var emailAddress: SoulverCore.DataPoint<SoulverCore.EmailFromTokenParser> {
    get
  }
  public static var hashtag: SoulverCore.DataPoint<SoulverCore.HashtagFromTokenParser> {
    get
  }
  public static var whitespace: SoulverCore.DataPoint<SoulverCore.WhitespaceFromTokenParser> {
    get
  }
  public static var screenResolution: SoulverCore.DataPoint<SoulverCore.ScreenResolutionFromTokenParser> {
    get
  }
  public static var substance: SoulverCore.DataPoint<SoulverCore.SubstanceFromTokenParser> {
    get
  }
  public static var pitch: SoulverCore.DataPoint<SoulverCore.PitchFromTokenParser> {
    get
  }
  public static var keyword: SoulverCore.DataPoint<SoulverCore.KeywordFromTokenParser> {
    get
  }
}
public struct NumberFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = Foundation.Decimal
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.NumberFromTokenParser.DataType?
}
public struct DigitsFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = Swift.String
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.DigitsFromTokenParser.DataType?
}
public struct BinaryNumberFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = Swift.UInt
  public func parseDataFrom(token: SoulverCore.Token) -> Swift.UInt?
}
public struct OctalNumberFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = Swift.UInt
  public func parseDataFrom(token: SoulverCore.Token) -> Swift.UInt?
}
public struct HexNumberFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = Swift.UInt
  public func parseDataFrom(token: SoulverCore.Token) -> Swift.UInt?
}
public struct DateFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = Foundation.Date
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.DateFromTokenParser.DataType?
}
public struct DatestampFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = SoulverCore.Datestamp
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.DatestampFromTokenParser.DataType?
}
public struct PercentageFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = Foundation.Decimal
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.PercentageFromTokenParser.DataType?
}
public struct URLFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = Foundation.URL
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.URLFromTokenParser.DataType?
}
public struct EmailFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = Swift.String
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.EmailFromTokenParser.DataType?
}
public struct WhitespaceFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = Swift.String
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.WhitespaceFromTokenParser.DataType?
}
public struct BooleanFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = Swift.Bool
  public func parseDataFrom(token: SoulverCore.Token) -> Swift.Bool?
}
public struct PlaceFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = SoulverCore.Place
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.Place?
}
public struct HashtagFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = Swift.String
  public func parseDataFrom(token: SoulverCore.Token) -> Swift.String?
}
public struct SubstanceFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = SoulverCore.Substance
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.Substance?
}
public struct AirportFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = SoulverCore.Airport
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.Airport?
}
public struct CountryFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = SoulverCore.Country
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.Country?
}
public struct CityFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = SoulverCore.City
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.City?
}
public struct TimeZoneFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = SoulverCore.Place
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.Place?
}
public struct TimespanFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = SoulverCore.Timespan
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.Timespan?
}
public struct LaptimeFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = SoulverCore.Laptime
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.Laptime?
}
public struct TimecodeFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = SoulverCore.Frametime
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.Frametime?
}
public struct CurrencyCodeFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = SoulverCore.CurrencyCode
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.CurrencyCode?
}
public struct UnitOfTypeFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = SoulverCore.UnitExpression
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.UnitExpression?
}
public struct ScreenResolutionFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = SoulverCore.Resolution
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.Resolution?
}
public struct iso8601FromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = Foundation.Date
  public func parseDataFrom(token: SoulverCore.Token) -> Foundation.Date?
}
public struct UnixTimestampFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = Foundation.TimeInterval
  public func parseDataFrom(token: SoulverCore.Token) -> Foundation.TimeInterval?
}
public struct PitchFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = SoulverCore.Pitch
  public func parseDataFrom(token: SoulverCore.Token) -> SoulverCore.Pitch?
}
public struct KeywordFromTokenParser : SoulverCore.DataFromTokenParser {
  public typealias DataType = SoulverCore.Keyword
  public func parseDataFrom(token: SoulverCore.Token) -> (any SoulverCore.Keyword)?
}
public class ObjectParser {
  public init(_ expression: Swift.String, customization: SoulverCore.EngineCustomization = .standard)
  public func parse<T>(_ type: T.Type) throws -> T where T : SoulverCore.ParsableObject
  public enum ScanningError : Swift.Error {
    case scanFailed
    case missingKeywordType(any SoulverCore.Keyword.Type)
    case missingWords(words: Swift.Set<Swift.String>)
  }
  public func reset()
  public func scan<T>(_ entity: SoulverCore.DataPoint<T>) throws -> T.DataType where T : SoulverCore.DataFromTokenParser
  public func scanKeyword<T>(ofType keywordType: T.Type) throws -> T where T : SoulverCore.Keyword
  public func matchesStructure(of otherExpression: Swift.String, caseSensitive: Swift.Bool = true, keywordTypes: SoulverCore.KeywordTypeList? = nil) -> Swift.Bool
  public func containsType(tokenType: SoulverCore.TokenType) -> Swift.Bool
  public func ensurePresent(words: Swift.Set<Swift.String>, caseSensitive: Swift.Bool = false) throws
  public func parseAllDataTypes() -> [Any]
  public func replacingFirst<T>(_ entity: SoulverCore.DataPoint<T>, replacement: (T.DataType) -> Swift.String?) -> Swift.String where T : SoulverCore.DataFromTokenParser
  public func replacingAll<T>(_ entity: SoulverCore.DataPoint<T>, replacement: (T.DataType) -> Swift.String?) -> Swift.String where T : SoulverCore.DataFromTokenParser
  @objc deinit
}
public protocol ParsableObject {
  init(from parser: SoulverCore.ObjectParser) throws
  static var keywordTypes: SoulverCore.KeywordTypeList? { get }
}
extension SoulverCore.ParsableObject {
  public static var keywordTypes: SoulverCore.KeywordTypeList? {
    get
  }
}
public typealias KeywordTypeList = [any SoulverCore.Keyword.Type]
public struct CustomPlace : Swift.Equatable, Swift.Hashable {
  public let name: Swift.String
  public let timeZone: Foundation.TimeZone
  public let gpsCoordinates: SoulverCore.GPSCoordinates?
  public static func == (a: SoulverCore.CustomPlace, b: SoulverCore.CustomPlace) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct UnitRange {
  public let lowerBound: Foundation.Decimal
  public let upperBound: Foundation.Decimal
  public let unit: SoulverCore.SCUnit
}
public struct DegreesMinutesSeconds : Swift.Equatable {
  public enum CardinalDirection : Swift.String, Swift.CaseIterable, Swift.Equatable {
    case north
    case south
    case east
    case west
    public init?(rawValue: Swift.String)
    public typealias AllCases = [SoulverCore.DegreesMinutesSeconds.CardinalDirection]
    public typealias RawValue = Swift.String
    nonisolated public static var allCases: [SoulverCore.DegreesMinutesSeconds.CardinalDirection] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  public let degrees: Foundation.Decimal
  public let minutes: Foundation.Decimal
  public let seconds: Foundation.Decimal
  public let cardinalDirection: SoulverCore.DegreesMinutesSeconds.CardinalDirection?
  public static func == (a: SoulverCore.DegreesMinutesSeconds, b: SoulverCore.DegreesMinutesSeconds) -> Swift.Bool
}
public struct Holiday {
  public init(day: Swift.Int, month: Swift.Int, year: Swift.Int)
  public let day: Swift.Int
  public let month: Swift.Int
  public let year: Swift.Int
  public var description: Swift.String?
}
extension SoulverCore.Holiday : Swift.Hashable, Swift.Equatable, Swift.Codable {
  public static func == (a: SoulverCore.Holiday, b: SoulverCore.Holiday) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
infix operator ~ : AdditionPrecedence
public enum TimezoneCodeCorrectionBehavior {
  case automatic
  case onlyNonSummerCodes
  case never
  public static func == (a: SoulverCore.TimezoneCodeCorrectionBehavior, b: SoulverCore.TimezoneCodeCorrectionBehavior) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct PercentageRate : Swift.Equatable {
  public static func == (a: SoulverCore.PercentageRate, b: SoulverCore.PercentageRate) -> Swift.Bool
}
public struct DateParsingOptions : Swift.Hashable, Swift.Equatable, Swift.Sendable {
  public init(defaultTimeForSingleDate: SoulverCore.DateParsingOptions.DefaultTimeForDate = .noon, defaultTimeForDateRange: SoulverCore.DateParsingOptions.DefaultTimeForDate = .startOfDay, preferFutureForAmbiguousDates: Swift.Bool = false, seeksDate: Swift.Bool = false)
  public static let futureDateSeeking: SoulverCore.DateParsingOptions
  public enum DefaultTimeForDate : Swift.Sendable {
    case startOfDay
    case noon
    public static func == (a: SoulverCore.DateParsingOptions.DefaultTimeForDate, b: SoulverCore.DateParsingOptions.DefaultTimeForDate) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var defaultTimeForSingleDate: SoulverCore.DateParsingOptions.DefaultTimeForDate
  public var defaultTimeForDateRange: SoulverCore.DateParsingOptions.DefaultTimeForDate
  public var preferFutureForAmbiguousDates: Swift.Bool
  public var seeksDate: Swift.Bool
  public static func == (a: SoulverCore.DateParsingOptions, b: SoulverCore.DateParsingOptions) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension SoulverCore.DateParsingOptions {
  @available(*, deprecated, message: "Enable seeksDate and preferFutureForAmbiguousDates to match the previous behavior of seeksFutureDate. This property has been split across two properties for higher granularity in date parsing.")
  public var seeksFutureDate: Swift.Bool {
    get
    set
  }
}
public enum StatisticType : Swift.Int, Swift.RawRepresentable, Swift.CaseIterable, Swift.Equatable, Swift.Codable, Swift.Sendable {
  case total
  case average
  case count
  case median
  case lesser
  case greater
  case lcm
  case gcd
  case standardDeviation
  case reduction
  public init?(rawValue: Swift.Int)
  public typealias AllCases = [SoulverCore.StatisticType]
  public typealias RawValue = Swift.Int
  nonisolated public static var allCases: [SoulverCore.StatisticType] {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
public struct CustomFunction {
  public init(prototypeExpression: SoulverCore.PrototypeExpression, handler: @escaping SoulverCore.CustomFunctionHandler)
  public var backgroundHandler: SoulverCore.BackgroundCustomFunctionHandler?
  public var customTypes: [SoulverCore.CustomType]?
  public var aliases: [SoulverCore.PrototypeExpression]?
  public var prerequisiteTypes: SoulverCore.TokenTypeSet?
  public var identifier: Swift.String?
}
extension SoulverCore.CustomFunction : Swift.Hashable, Swift.Equatable {
  public static func == (lhs: SoulverCore.CustomFunction, rhs: SoulverCore.CustomFunction) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public typealias CustomFunctionHandler = (_ parameters: [SoulverCore.EvaluationResult]) -> SoulverCore.EvaluationResult
public typealias BackgroundCustomFunctionHandler = (_ parameters: [SoulverCore.EvaluationResult]) async throws -> SoulverCore.EvaluationResult
public typealias PrototypePlaceholder = Swift.String
public struct CustomType {
  public init(prototypePlaceholder: SoulverCore.PrototypePlaceholder, symbols: [Swift.String], associatedObject: Any?)
  public let prototypePlaceholder: SoulverCore.PrototypePlaceholder
  public let symbols: [Swift.String]
  public let associatedObject: Any?
}
extension SoulverCore.CustomType : Swift.Hashable, Swift.Equatable {
  public static func == (lhs: SoulverCore.CustomType, rhs: SoulverCore.CustomType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension SoulverCore.FunctionIdentifier : Swift.Equatable {}
extension SoulverCore.FunctionIdentifier : Swift.Hashable {}
extension SoulverCore.ConverterIdentifier : Swift.Equatable {}
extension SoulverCore.ConverterIdentifier : Swift.Hashable {}
extension SoulverCore.TokenListSemantics.EnumerationGranularity : Swift.Equatable {}
extension SoulverCore.TokenListSemantics.EnumerationGranularity : Swift.Hashable {}
extension SoulverCore.EvaluationError : Swift.Equatable {}
extension SoulverCore.EvaluationError : Swift.Hashable {}
extension SoulverCore.UnitType : Swift.Equatable {}
extension SoulverCore.UnitType : Swift.Hashable {}
extension SoulverCore.UnitType : Swift.RawRepresentable {}
extension SoulverCore.UnitIdentifier : Swift.Equatable {}
extension SoulverCore.UnitIdentifier : Swift.Hashable {}
extension SoulverCore.TokenSubType : Swift.Equatable {}
extension SoulverCore.TokenSubType : Swift.Hashable {}
extension SoulverCore.UnitMeasurementSystem : Swift.Hashable {}
extension SoulverCore.SIThreshold : Swift.Equatable {}
extension SoulverCore.SIThreshold : Swift.Hashable {}
extension SoulverCore.SIThreshold : Swift.RawRepresentable {}
extension SoulverCore.LineCollectionEditingHelper : Swift.Sendable {}
extension SoulverCore.LineCollectionEnumerator.ReferenceSubstituionPolicy : Swift.Equatable {}
extension SoulverCore.LineCollectionEnumerator.ReferenceSubstituionPolicy : Swift.Hashable {}
extension SoulverCore.LineCollectionEnumerator.ResultFormatting : Swift.Equatable {}
extension SoulverCore.LineCollectionEnumerator.ResultFormatting : Swift.Hashable {}
extension SoulverCore.Subsheet.SubsheetEvaluatorType : Swift.Equatable {}
extension SoulverCore.Subsheet.SubsheetEvaluatorType : Swift.Hashable {}
extension SoulverCore.Subsheet.SubsheetEvaluatorType : Swift.RawRepresentable {}
extension SoulverCore.Line.CalculationBehaviour : Swift.Equatable {}
extension SoulverCore.Line.CalculationBehaviour : Swift.Hashable {}
extension SoulverCore.Line.CalculationBehaviour : Swift.RawRepresentable {}
extension SoulverCore.Line.ExpressionAlignment : Swift.Equatable {}
extension SoulverCore.Line.ExpressionAlignment : Swift.Hashable {}
extension SoulverCore.Line.ExpressionAlignment : Swift.RawRepresentable {}
extension SoulverCore.Line.ApparentLineType : Swift.Equatable {}
extension SoulverCore.Line.ApparentLineType : Swift.Hashable {}
extension SoulverCore.Line.HighlightPortion : Swift.RawRepresentable {}
extension SoulverCore.Datestamp.DatestampType : Swift.Equatable {}
extension SoulverCore.Datestamp.DatestampType : Swift.Hashable {}
extension SoulverCore.ScalarSystem : Swift.Equatable {}
extension SoulverCore.ScalarSystem : Swift.Hashable {}
extension SoulverCore.ScalarSystem : Swift.RawRepresentable {}
extension SoulverCore.MisplacedThousandsSeparatorBehavior : Swift.Equatable {}
extension SoulverCore.MisplacedThousandsSeparatorBehavior : Swift.Hashable {}
extension SoulverCore.AlternativeResult.Format : Swift.Equatable {}
extension SoulverCore.AlternativeResult.Format : Swift.Hashable {}
extension SoulverCore.NotationPreferences.NotationStyle : Swift.Equatable {}
extension SoulverCore.NotationPreferences.NotationStyle : Swift.Hashable {}
extension SoulverCore.Variable.VariableType : Swift.Equatable {}
extension SoulverCore.Variable.VariableType : Swift.Hashable {}
extension SoulverCore.TokenType : Swift.Equatable {}
extension SoulverCore.TokenType : Swift.Hashable {}
extension SoulverCore.SemanticToken.PartOfExpression : Swift.Equatable {}
extension SoulverCore.SemanticToken.PartOfExpression : Swift.Hashable {}
extension SoulverCore.UnitSymbolReplacement.UnitSymbolReplacementPosition : Swift.Equatable {}
extension SoulverCore.UnitSymbolReplacement.UnitSymbolReplacementPosition : Swift.Hashable {}
extension SoulverCore.DegreesMinutesSeconds.CardinalDirection : Swift.Hashable {}
extension SoulverCore.DegreesMinutesSeconds.CardinalDirection : Swift.RawRepresentable {}
extension SoulverCore.TimezoneCodeCorrectionBehavior : Swift.Equatable {}
extension SoulverCore.TimezoneCodeCorrectionBehavior : Swift.Hashable {}
extension SoulverCore.DateParsingOptions.DefaultTimeForDate : Swift.Equatable {}
extension SoulverCore.DateParsingOptions.DefaultTimeForDate : Swift.Hashable {}
extension SoulverCore.StatisticType : Swift.Hashable {}
